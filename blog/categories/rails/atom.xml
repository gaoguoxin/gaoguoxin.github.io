<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | ruby and rails study]]></title>
  <link href="http://gaoguoxin.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://gaoguoxin.github.io/"/>
  <updated>2014-02-27T00:43:20+00:00</updated>
  <id>http://gaoguoxin.github.io/</id>
  <author>
    <name><![CDATA[naitnix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails_initialize]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/rails-initialize/"/>
    <updated>2014-02-25T09:26:57+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/rails-initialize</id>
    <content type="html"><![CDATA[<p>我们经常在我们的rails项目的根目录执行这样的操作，比如:</p>

<p>``` ruby</p>

<p>rails s  #=> 启动本地服务器，让我们的项目跑起来
rails c  #=> 启动console
rails db #=> 启动我们的database终端</p>

<p>```</p>

<p>上面的命令你可能已经再熟悉不过了，但是你想过没有，为什么rails命令可以执行?难道rails是我们系统的命令么?这就设计我本文要讲的，rails的启动流成了。在你的终端输入</p>

<p>``` bash</p>

<p>which rails #=> /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin/rails (这个路径是你的rails可执行文件的所在路径)</p>

<p>echo $PATH  #=> /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin (我们的系统环境变量)</p>

<p>```</p>

<!-- more -->


<p>以上输出说明，我们的rails命令是一个可执行脚本文件，并且这个脚本文件被我们添加到了系统的环境变量。下面我们来看看这个脚本的具体内容:</p>

<p>``` ruby  /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin/rails</p>

<h1>!/usr/bin/env ruby  这句话的意思是使用系统环境变量中的ruby解释器，与shell中的  #!/usr/bin/bash不同</h1>

<p>#</p>

<h1>This file was generated by RubyGems.</h1>

<p>#</p>

<h1>The application &lsquo;railties&rsquo; is installed as part of a gem, and</h1>

<h1>this file is here to facilitate running it.</h1>

<p>#</p>

<p>require &lsquo;rubygems&rsquo;  #加载rubygems</p>

<p>version = &ldquo;>= 0&rdquo;</p>

<p>if ARGV.first =~ /^<em>(.*)</em>$/ and Gem::Version.correct? $1 then
  version = $1
  ARGV.shift
end</p>

<p>gem &lsquo;railties&rsquo;, version #导入railties这个gem，这是rails中的核心概念
load Gem.bin_path(&lsquo;railties&rsquo;, &lsquo;rails&rsquo;, version)  #加载railties目录下的rails</p>

<p>```</p>

<p>如果我们在我们项目的根目录输入 bundle show rails 看一下我们的rails装在了哪里，他会告诉我们类似下面这样的一个路径:</p>

<p>``` ruby</p>

<p>/home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/rails-3.2.16</p>

<p>```</p>

<p>如果我们进入这个目录查看里面的内容，你会发现里面是空的，这是怎么回事?</p>

<p>``` ruby</p>

<p>cd /home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/rails-3.2.16</p>

<p>ls # => 空的，没有任何内容</p>

<p>```</p>

<p>自rails3起，rails的所有的源代码都放到了railties 里面，如果我们回到 上面一个目录，你会发现有一个对应的 railties-3.2.16目录:</p>

<p>``` ruby</p>

<p>cd ../</p>

<p>ls #=> railties-3.2.16</p>

<p>cd railties-3.2.16</p>

<p>ls -l</p>

<p>drwxrwxr-x 2 naitnix naitnix 4096 Feb  8 08:56 bin
-rw-r&mdash;r&mdash; 1 naitnix naitnix 4966 Dec  9 05:44 CHANGELOG.md
drwxrwxr-x 6 naitnix naitnix 4096 Dec  9 05:44 guides
drwxrwxr-x 3 naitnix naitnix 4096 Dec  9 05:44 lib
-rw-r&mdash;r&mdash; 1 naitnix naitnix  765 Dec  9 05:44 README.rdoc</p>

<p>```</p>

<p>如果你从github  clone了rails的源码的话，你会发现他的代码结构与我们上面的目录类似，只是多了几个rails的组件:</p>

<p>``` ruby</p>

<p>drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionmailer
drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionpack
drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionview
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activemodel
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activerecord
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activesupport
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 ci
-rw-rw-r&mdash; 1 naitnix naitnix 1203 Feb 20 09:10 CONTRIBUTING.md
-rw-rw-r&mdash; 1 naitnix naitnix 2203 Feb 20 09:10 Gemfile
drwxrwxr-x 7 naitnix naitnix 4096 Feb 20 09:10 guides
-rw-rw-r&mdash; 1 naitnix naitnix  524 Feb 20 09:10 install.rb
-rw-rw-r&mdash; 1 naitnix naitnix   51 Feb 20 09:10 load_paths.rb
-rw-rw-r&mdash; 1 naitnix naitnix 1159 Feb 20 09:10 rails.gemspec
-rw-rw-r&mdash; 1 naitnix naitnix   10 Feb 20 09:10 RAILS_VERSION
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 railties
-rw-rw-r&mdash; 1 naitnix naitnix 2844 Feb 20 09:10 Rakefile
-rw-rw-r&mdash; 1 naitnix naitnix 4029 Feb 20 09:10 README.md
-rw-rw-r&mdash; 1 naitnix naitnix 7671 Feb 20 09:10 RELEASING_RAILS.rdoc
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 tasks
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 tools
-rw-rw-r&mdash; 1 naitnix naitnix  158 Feb 20 09:10 version.rb</p>

<p>```</p>

<p>你会看到上面的列表中有个railties目录，这个目录就是我们上面说的rails启动流程的源码目录，让我们进入这个目录看看:</p>

<p>``` ruby</p>

<p>drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 bin
-rw-rw-r&mdash; 1 naitnix naitnix 8898 Feb 20 09:10 CHANGELOG.md
drwxrwxr-x 3 naitnix naitnix 4096 Feb 20 09:10 lib
-rw-rw-r&mdash; 1 naitnix naitnix 1072 Feb 20 09:10 MIT-LICENSE
-rw-rw-r&mdash; 1 naitnix naitnix 1028 Feb 20 09:10 railties.gemspec
-rw-rw-r&mdash; 1 naitnix naitnix 1296 Feb 20 09:10 Rakefile
-rw-rw-r&mdash; 1 naitnix naitnix 3382 Feb 20 09:10 RDOC_MAIN.rdoc
-rw-rw-r&mdash; 1 naitnix naitnix  803 Feb 20 09:10 README.rdoc
drwxrwxr-x 9 naitnix naitnix 4096 Feb 20 09:10 test</p>

<p>```</p>

<p>里面有两个目录我们需要关心，一个是bin，另一个是lib，我们在这篇文章开始说的，rails可执行文件要加载一个railties目录下的rails可执行文件，这个rails可执行文件就在这个bin目录。lib目录，里面有个rails目录，这个目录里的代码才使我们真正的启动相关的代码所在:</p>

<p>``` ruby</p>

<p>-rw-rw-r&mdash; 1 naitnix naitnix   211 Feb 20 09:10 all.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 api
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 application
-rw-rw-r&mdash; 1 naitnix naitnix   463 Feb 20 09:10 application_controller.rb
-rw-rw-r&mdash; 1 naitnix naitnix 14732 Feb 20 09:10 application.rb
-rw-rw-r&mdash; 1 naitnix naitnix  1950 Feb 20 09:10 app_rails_loader.rb
-rw-rw-r&mdash; 1 naitnix naitnix   857 Feb 20 09:10 backtrace_cleaner.rb
-rw-rw-r&mdash; 1 naitnix naitnix   381 Feb 20 09:10 cli.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2087 Feb 20 09:10 code_statistics_calculator.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2836 Feb 20 09:10 code_statistics.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 commands
-rw-rw-r&mdash; 1 naitnix naitnix   328 Feb 20 09:10 commands.rb
-rw-rw-r&mdash; 1 naitnix naitnix  3619 Feb 20 09:10 configuration.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 console
-rw-rw-r&mdash; 1 naitnix naitnix   500 Feb 20 09:10 deprecation.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 engine
-rw-rw-r&mdash; 1 naitnix naitnix 24556 Feb 20 09:10 engine.rb
drwxrwxr-x 9 naitnix naitnix  4096 Feb 20 09:10 generators
-rw-rw-r&mdash; 1 naitnix naitnix  9853 Feb 20 09:10 generators.rb
-rw-rw-r&mdash; 1 naitnix naitnix   588 Feb 20 09:10 info_controller.rb
-rw-rw-r&mdash; 1 naitnix naitnix  3129 Feb 20 09:10 info.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2276 Feb 20 09:10 initializable.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2175 Feb 20 09:10 mailers_controller.rb
-rw-rw-r&mdash; 1 naitnix naitnix  5664 Feb 20 09:10 paths.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 rack
-rw-rw-r&mdash; 1 naitnix naitnix   190 Feb 20 09:10 rack.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 railtie
-rw-rw-r&mdash; 1 naitnix naitnix  7467 Feb 20 09:10 railtie.rb
-rw-rw-r&mdash; 1 naitnix naitnix   985 Feb 20 09:10 rubyprof_ext.rb
-rw-rw-r&mdash; 1 naitnix naitnix   302 Feb 20 09:10 ruby_version_check.rb
-rw-rw-r&mdash; 1 naitnix naitnix  4456 Feb 20 09:10 source_annotation_extractor.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 tasks
-rw-rw-r&mdash; 1 naitnix naitnix   188 Feb 20 09:10 tasks.rb
drwxrwxr-x 4 naitnix naitnix  4096 Feb 20 09:10 templates
-rw-rw-r&mdash; 1 naitnix naitnix  1218 Feb 20 09:10 test_help.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 test_unit
-rw-rw-r&mdash; 1 naitnix naitnix   158 Feb 20 09:10 version.rb
-rw-rw-r&mdash; 1 naitnix naitnix   150 Feb 20 09:10 welcome_controller.rb</p>

<p>```</p>

<p>如果我们看见一些以Rails开头的路径，多半指的是这个rails目录。</p>

<p>好，介绍完了rails的源码目录结构，我们接着我们开头的部分讲，当我们在终端输入rails 命令后，系统会到环境变量的目录中查找到rails可执行文件，并利用环境变量中的ruby解释器去解释这个文件，那么我们在前面看到了，这个文件主要做了两件是:第一时间在rubygems,第二就是 load了rails源码目录(bin/rails)中的rails命令文件，那么我们来看看这个rails可执行文件中到底做了哪些事:</p>

<p>``` ruby railties/bin/rails</p>

<h1>!/usr/bin/env ruby</h1>

<p>if File.exists?(File.join(File.expand_path(&lsquo;../../..&rsquo;, <strong>FILE</strong>), &lsquo;.git&rsquo;))
  railties_path = File.expand_path(&lsquo;../../lib&rsquo;, <strong>FILE</strong>)
  $:.unshift(railties_path)
end
require &ldquo;rails/cli&rdquo;</p>

<p>```</p>

<p>这个文件主要是require了 /home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.16/lib/rails/cli.rb这个文件，所以，让我们来看看这个cli.rb文件到底做了写什么</p>

<p>``` ruby lib/rails/cli.rb</p>

<p>require &lsquo;rails/app_rails_loader&rsquo;</p>

<h1>If we are inside a Rails application this method performs an exec and thus</h1>

<h1>the rest of this script is not run.</h1>

<p>Rails::AppRailsLoader.exec_app_rails</p>

<p>require &lsquo;rails/ruby_version_check&rsquo;
Signal.trap(&ldquo;INT&rdquo;) { puts; exit(1) }</p>

<p>if ARGV.first == &lsquo;plugin&rsquo;
  ARGV.shift
  require &lsquo;rails/commands/plugin&rsquo;
else
  require &lsquo;rails/commands/application&rsquo;
end</p>

<p>```</p>

<p>这个文件主要做了这么几件事:</p>

<ul>
<li>require 了 rails 目录下的app_rails_loader文件</li>
<li>执行exec_app_rails方法</li>
<li>做ruby版本的检查</li>
<li>判断rails命令后面的参数，如果跟的是plugin那么require rails/commands/plugin这个文件，否则的话，require rails/commands/application</li>
</ul>


<p>接下来，我们看看这个app_rails_loader文件中的exec_app_rails方法:</p>

<p>``` ruby app_rails_loader.rb</p>

<p>RUBY = Gem.ruby  #定义常量
EXECUTABLES = [&lsquo;bin/rails&rsquo;, &lsquo;script/rails&rsquo;]#rails可执行文件的目录</p>

<p>def self.exec_app_rails
  original_cwd = Dir.pwd</p>

<p>  loop do</p>

<pre><code>if exe = find_executable
  contents = File.read(exe)  #contents为bin/rails或者script/rails

  if contents =~ /(APP|ENGINE)_PATH/#如果contents为script/rails，则表示我们当前执行rails命令的目录是我们项目的根目录
    exec RUBY, exe, *ARGV执行script/rails命令
    break # non reachable, hack to be able to stub exec in the test suite
  elsif exe.end_with?('bin/rails') &amp;&amp; contents.include?('This file was generated by Bundler')
    #rails4 里面，移除了script目录，添加了bin目录，并将rails，bundle，rake等命令放到了这个bin目录
    $stderr.puts(BUNDLER_WARNING)
    Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))#设置常量 APP_PATH
    require File.expand_path('../boot', APP_PATH) #require  boot.rb
    require 'rails/commands' # require lib/rails/commands.rb文件
    break
  end
end

# If we exhaust the search there is no executable, this could be a
# call to generate a new application, so restore the original cwd.
Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

# Otherwise keep moving upwards in search of an executable.
Dir.chdir('..')
</code></pre>

<p>  end
end</p>

<p>def self.find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end</p>

<p>```</p>

<p>那么来看看这个script/rails(或者bin/rails)文件里都做了哪些事:</p>

<p>``` ruby script/rails(bin/rails)</p>

<p>APP_PATH = File.expand_path(&lsquo;../../config/application&rsquo;,  <strong>FILE</strong>)#设置常量 APP_PATH
require File.expand_path(&lsquo;../../config/boot&rsquo;,  <strong>FILE</strong>)#require  boot.rb
require &lsquo;rails/commands&rsquo;# require lib/rails/commands.rb文件</p>

<p>```</p>

<p>看看项目目录中的config/boot.rb文件的内容:</p>

<p>``` ruby config/boot.rb</p>

<h1>Set up gems listed in the Gemfile.</h1>

<p>ENV[&lsquo;BUNDLE_GEMFILE&rsquo;] ||= File.expand_path(&lsquo;../../Gemfile&rsquo;, <strong>FILE</strong>)</p>

<p>require &lsquo;bundler/setup&rsquo; if File.exists?(ENV[&lsquo;BUNDLE_GEMFILE&rsquo;])</p>

<p>```</p>

<p>这个文件的内容很简单，load  Gemfile文件并run bundler。接下来我们看一下 railties/lib/rails/commands.rb文件:</p>

<p>``` ruby railties/lib/rails/commands.rb</p>

<p>ARGV &lt;&lt; &lsquo;&mdash;help&rsquo; if ARGV.empty?</p>

<p>aliases = {  #设置了几个常用的命令别名
  &ldquo;g&rdquo;  => &ldquo;generate&rdquo;,
  &ldquo;d&rdquo;  => &ldquo;destroy&rdquo;,
  &ldquo;c&rdquo;  => &ldquo;console&rdquo;,
  &ldquo;s&rdquo;  => &ldquo;server&rdquo;,
  &ldquo;db&rdquo; => &ldquo;dbconsole&rdquo;,
  &ldquo;r&rdquo;  => &ldquo;runner&rdquo;
}</p>

<p>command = ARGV.shift
command = aliases[command] || command</p>

<p>require &lsquo;rails/commands/commands_tasks&rsquo;</p>

<p>Rails::CommandsTasks.new(ARGV).run_command!(command) #执行命令方法</p>

<p>```</p>

<p>上面的执行命令的方法在rails/commands/commands_tasks.rb文件，我们来看看:</p>

<p>``` ruby rails/commands/commands_tasks.rb</p>

<p>module Rails
  # This is a class which takes in a rails command and initiates the appropriate
  # initiation sequence.
  #
  # Warning: This class mutates ARGV because some commands require manipulating
  # it before they are run.
  class CommandsTasks # :nodoc:</p>

<pre><code>attr_reader :argv

HELP_MESSAGE = &lt;&lt;-EOT
</code></pre>

<p>Usage: rails COMMAND [ARGS]</p>

<p>The most common rails commands are:
 generate    Generate new code (short-cut alias: &ldquo;g&rdquo;)
 console     Start the Rails console (short-cut alias: &ldquo;c&rdquo;)
 server      Start the Rails server (short-cut alias: &ldquo;s&rdquo;)
 dbconsole   Start a console for the database specified in config/database.yml</p>

<pre><code>         (short-cut alias: "db")
</code></pre>

<p> new         Create a new Rails application. &ldquo;rails new my_app&rdquo; creates a</p>

<pre><code>         new application called MyApp in "./my_app"
</code></pre>

<p>In addition to those, there are:
 application  Generate the Rails application code
 destroy      Undo code generated with &ldquo;generate&rdquo; (short-cut alias: &ldquo;d&rdquo;)
 plugin new   Generates skeleton for developing a Rails plugin
 runner       Run a piece of code in the application environment (short-cut alias: &ldquo;r&rdquo;)</p>

<p>All commands can be run with -h (or &mdash;help) for more information.
EOT</p>

<pre><code>COMMAND_WHITELIST = %(plugin generate destroy console server dbconsole application runner new version help)

def initialize(argv)
  @argv = argv
end

def run_command!(command)
  command = parse_command(command)
  if COMMAND_WHITELIST.include?(command)
    send(command)
  else
    write_error_message(command)
  end
end

def plugin
  require_command!("plugin")
end

def generate
  generate_or_destroy(:generate)
end

def destroy
  generate_or_destroy(:destroy)
end

def console
  require_command!("console")
  options = Rails::Console.parse_arguments(argv)

  # RAILS_ENV needs to be set before config/application is required
  ENV['RAILS_ENV'] = options[:environment] if options[:environment]

  # shift ARGV so IRB doesn't freak
  shift_argv!

  require_application_and_environment!
  Rails::Console.start(Rails.application, options)
end

def server
  set_application_directory!
  require_command!("server")

  Rails::Server.new.tap do |server|
    # We need to require application after the server sets environment,
    # otherwise the --environment option given to the server won't propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  end
end

def dbconsole
  require_command!("dbconsole")
  Rails::DBConsole.start
end

def application
  require_command!("application")
end

def runner
  require_command!("runner")
end

def new
  if %w(-h --help).include?(argv.first)
    require_command!("application")
  else
    exit_with_initialization_warning!
  end
end

def version
  argv.unshift '--version'
  require_command!("application")
end

def help
  write_help_message
end

private

  def exit_with_initialization_warning!
    puts "Can't initialize a new Rails application within the directory of another, please change to a non-Rails directory first.\n"
    puts "Type 'rails' for help."
    exit(1)
  end

  def shift_argv!
    argv.shift if argv.first &amp;&amp; argv.first[0] != '-'
  end

  def require_command!(command)
    require "rails/commands/#{command}"
  end

  def generate_or_destroy(command)
    require 'rails/generators'
    require_application_and_environment!
    Rails.application.load_generators
    require "rails/commands/#{command}"
  end

  # Change to the application's path if there is no config.ru file in current directory.
  # This allows us to run `rails server` from other directories, but still get
  # the main config.ru and properly set the tmp directory.
  def set_application_directory!
    Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exist?(File.expand_path("config.ru"))
  end

  def require_application_and_environment!
    require APP_PATH
    Rails.application.require_environment!
  end

  def write_help_message
    puts HELP_MESSAGE
  end

  def write_error_message(command)
    puts "Error: Command '#{command}' not recognized"
    if %x{rake #{command} --dry-run 2&gt;&amp;1 } &amp;&amp; $?.success?
      puts "Did you mean: `$ rake #{command}` ?\n\n"
    end
    write_help_message
    exit(1)
  end

  def parse_command(command)
    case command
    when '--version', '-v'
      'version'
    when '--help', '-h'
      'help'
    else
      command
    end
  end
</code></pre>

<p>  end
end</p>

<p>```
看一下server这个方法，首先跳转到项目根目录，紧接着require commonds/server.rb这个文件，接着，new了一个Rails::Server的实例并启动这个server，接下来我们看看server.rb的内容：</p>

<p>``` ruby  server.rb</p>

<p>class Server &lt; ::Rack::Server  #继承了Rack::Server，说明我们的rails应用也是一个Rack application
  def initialize(*)</p>

<pre><code>super
set_environment
</code></pre>

<p>  end</p>

<p>  def set_environment</p>

<pre><code>ENV["RAILS_ENV"] ||= options[:environment]
</code></pre>

<p>  end</p>

<p>  def start   # 重写了Rack::Server的start方法</p>

<pre><code>print_boot_information
trap(:INT) { exit }
create_tmp_directories
log_to_stdout if options[:log_stdout]

super #调用Rack::Server的start方法
</code></pre>

<p>  ensure</p>

<pre><code># The '-h' option calls exit before @options is set.
# If we call 'options' with it unset, we get double help banners.
puts 'Exiting' unless @options &amp;&amp; options[:daemonize]
</code></pre>

<p>  end</p>

<p>  def print_boot_information</p>

<pre><code>url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
puts "=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}"
puts "=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
puts "=&gt; Run `rails server -h` for more startup options"

if options[:Host].to_s.match(/0\.0\.0\.0/)
  puts "=&gt; Notice: server is listening on all interfaces (#{options[:Host]}). Consider using 127.0.0.1 (--binding option)"
end

puts "=&gt; Ctrl-C to shutdown server" unless options[:daemonize]
</code></pre>

<p>  end</p>

<p>  def create_tmp_directories</p>

<pre><code>%w(cache pids sessions sockets).each do |dir_to_make|
  FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
end
</code></pre>

<p>  end</p>

<p>  def log_to_stdout</p>

<pre><code>wrapped_app # touch the app so the logger is set up

console = ActiveSupport::Logger.new($stdout)
console.formatter = Rails.logger.formatter
console.level = Rails.logger.level

Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
</code></pre>

<p>  end
end</p>

<p>def default_options  #重写了Rack的default_options，这里你可以修改端口号，设置启动环境的优先级，及pid文件位置和config.ru文件的路径
  super.merge({</p>

<pre><code>Port:               3000,
DoNotReverseLookup: true,
environment:        (ENV['RAILS_ENV'] || ENV['RACK_ENV'] || "development").dup,
daemonize:          false,
debugger:           false,
pid:                File.expand_path("tmp/pids/server.pid"),
config:             File.expand_path("config.ru")
</code></pre>

<p>  })
end</p>

<p>```
可以看到这个server继承了Rack::Server，说明，我们的rails 项目也是一个Rack application, rack  application  在启动的时候会去寻找一个叫做config.ru的文件:</p>

<p>``` ruby</p>

<p>require ::File.expand_path(&lsquo;../config/environment&rsquo;,  <strong>FILE</strong>)
run Rails.application</p>

<p>```</p>

<p>这个文件 require了config/enviromnent.rb 文件，并启动我们的application，这样我们的server就启动起来了。那么我们的服务启动的时候是怎么加载我们的项目的呢，让我们看一下 config/environment.rb文件:</p>

<p>``` ruby config/environment.rb</p>

<h1>Load the Rails application.</h1>

<p>require File.expand_path(&lsquo;../application&rsquo;, <strong>FILE</strong>)</p>

<h1>Initialize the Rails application.</h1>

<p>R4pro::Application.initialize!</p>

<p>```</p>

<p>看上面的代码，这个文件只做了两件事:加载application.rb 文件 初始化我们的项目。我们先来看看这个application.rb文件:</p>

<p>``` ruby config/application.rb</p>

<p>require File.expand_path(&lsquo;../boot&rsquo;, <strong>FILE</strong>)</p>

<p>require &lsquo;rails/all&rsquo;</p>

<h1>Require the gems listed in Gemfile, including any gems</h1>

<h1>you&rsquo;ve limited to :test, :development, or :production.</h1>

<p>Bundler.require(:default, Rails.env)</p>

<p>module R4pro
  class Application &lt; Rails::Application</p>

<pre><code># Settings in config/environments/* take precedence over those specified here.
# Application configuration should go into files in config/initializers
# -- all .rb files in that directory are automatically loaded.

# Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
# Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
# config.time_zone = 'Central Time (US &amp; Canada)'

# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
</code></pre>

<p>  end
end</p>

<p>```
这个文件的第一行，require  boot.rb 文件，这个文件我们在上面说过，就是load Gemfile文件，并run  bundler 。紧接着第二行，require 了 railties/lib/rails/all.rb文件，这个all文件的内容:</p>

<p>``` ruby   all.rb</p>

<p>require &ldquo;rails&rdquo;</p>

<p>%w(
  active_record
  action_controller
  action_view
  action_mailer
  rails/test_unit
  sprockets
).each do |framework|
  begin</p>

<pre><code>require "#{framework}/railtie"
</code></pre>

<p>  rescue LoadError
  end
end</p>

<p>```</p>

<p>第一行，require了 lib/rails.rb文件，接下来，加载rails的各个模块下的railtie文件。接下来继续看config/application.rb</p>

<p>``` ruby application.rb</p>

<p>module R4pro
  class Application &lt; Rails::Application</p>

<pre><code># Settings in config/environments/* take precedence over those specified here.
# Application configuration should go into files in config/initializers
# -- all .rb files in that directory are automatically loaded.

# Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
# Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
# config.time_zone = 'Central Time (US &amp; Canada)'

# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>这个 class Application 继承自 Rails::Application，这个class将会在Rackup 文件中被传递到Rack server。我们再来看看Rails::Application</p>

<p>``` ruby  rails/application.rb</p>

<p>class Application &lt; Engine
  def inherited(base)</p>

<pre><code>super #调用Engine的super
Rails.application ||= base.instance #这个Rails是在lib/rails.rb中定义的一个module，这个application是它的一个attributes
</code></pre>

<p>  end</p>

<p>  def config  #这个及时我们rails项目中的config/application.rb 文件中的config 注意这个方法是个类方法，这样我们在我们的项目的config/application.rb文件中才可以使用config直接调用</p>

<pre><code>@config ||= Application::Configuration.new(find_root_with_flag("config.ru", Dir.pwd))  #这个配置在rails/application/configuration.rb文件
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>这个Application 类继承了 Engine，这就是说，我们的rails application 也是一个engine。当一个类继承了这个类的时候，base.instance 将会赋值到Rails.application ,这个base.instance将会创建一个我们项目的实例。这就是说，我们可以在我们的项目的任何一个地方使用Rails.application来访问我们的项目的实例。我们看看Engine.rb文件:</p>

<p>``` ruby rails/engine.rb</p>

<p>class Engine &lt; Railtie  #继承自 Railtie 类
  autoload :Configuration, &ldquo;rails/engine/configuration&rdquo; #加载 enging/configuration.rb这个文件</p>

<p>def inherited(base)
  unless base.abstract_railtie?</p>

<pre><code>Rails::Railtie::Configuration.eager_load_namespaces &lt;&lt; base

base.called_from = begin
  call_stack = if Kernel.respond_to?(:caller_locations)
    caller_locations.map(&amp;:path)
  else
    # Remove the line number from backtraces making sure we don't leave anything behind
    caller.map { |p| p.sub(/:\d+.*/, '') }
  end

  File.dirname(call_stack.detect { |p| p !~ %r[railties[\w.-]*/lib/rails|rack[\w.-]*/lib/rack] })
end
</code></pre>

<p>  end</p>

<p>  super  #调用Railtie这个类的inherited
end</p>

<p>def instance  #这个instance方法就是我们在application.rb 文件中 base.instance的出处
  @instance ||= new
end</p>

<p>end</p>

<p>```</p>

<p>这个Engine类继承了Railtie类，Railtie几乎遍布所有的ruby gems ，任何想要集成到rails项目的gems都应该有它自己的railtie。我们看看Railtie:</p>

<p>``` ruby  rails/railtie.rb</p>

<p>class Railtie
  autoload :Configuration, &ldquo;rails/railtie/configuration&rdquo;
  class &lt;&lt; self</p>

<pre><code>def inherited(base)
  unless base.abstract_railtie?
    subclasses &lt;&lt; base
  end
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>这个类没有继承其他的类，但是他include了一个confirugration.rb 文件，无论这个Railtie类什么时候被继承，这个文件都会被加载。 我们再来看看关于网站配置的文件,在rails/application.rb文件中，include了  lib/rails/application/configuration.rb 文件:</p>

<p>``` ruby appalication/configuration.rb</p>

<p>module Rails
  class Application</p>

<pre><code>class Configuration &lt; ::Rails::Engine::Configuration
  def initialize(*)
    super
    self.encoding = "utf-8"
    @allow_concurrency             = nil
    @consider_all_requests_local   = false
    @filter_parameters             = []
    @filter_redirect               = []
    @helpers_paths                 = []
    @serve_static_assets           = true
    @static_cache_control          = nil
    @force_ssl                     = false
    @ssl_options                   = {}
    @session_store                 = :cookie_store
    @session_options               = {}
    @time_zone                     = "UTC"
    @beginning_of_week             = :monday
    @log_level                     = nil
    @middleware                    = app_middleware
    @generators                    = app_generators
    @cache_store                   = [ :file_store, "#{root}/tmp/cache/" ]
    @railties_order                = [:all]
    @relative_url_root             = ENV["RAILS_RELATIVE_URL_ROOT"]
    @reload_classes_only_on_change = true
    @file_watcher                  = ActiveSupport::FileUpdateChecker
    @exceptions_app                = nil
    @autoflush_log                 = true
    @log_formatter                 = ActiveSupport::Logger::SimpleFormatter.new
    @eager_load                    = nil
    @secret_token                  = nil
    @secret_key_base               = nil

    @assets = ActiveSupport::OrderedOptions.new
    @assets.enabled                  = true
    @assets.paths                    = []
    @assets.precompile               = [ Proc.new { |path, fn| fn =~ /app\/assets/ &amp;&amp; !%w(.js .css).include?(File.extname(path)) },
                                         /(?:\/|\\|\A)application\.(css|js)$/ ]
    @assets.prefix                   = "/assets"
    @assets.version                  = '1.0'
    @assets.debug                    = false
    @assets.compile                  = true
    @assets.digest                   = false
    @assets.cache_store              = [ :file_store, "#{root}/tmp/cache/assets/#{Rails.env}/" ]
    @assets.js_compressor            = nil
    @assets.css_compressor           = nil
    @assets.logger                   = nil
  end
end
</code></pre>

<p>  end
end</p>

<p>```
这个Configurationl类在初始化的时候定义了很多的实例变量，这些变量大部分我们在做我们项目的配置的时候都见过。并且，这个类继承了::Rails::Engine::Configuration，我们再看看这个类:</p>

<p>``` ruby  engine/configuration.rb</p>

<p>module Rails
  class Engine</p>

<pre><code>class Configuration &lt; ::Rails::Railtie::Configuration
  attr_reader :root
  attr_writer :middleware, :eager_load_paths, :autoload_once_paths, :autoload_paths

  def initialize(root=nil)
    super()
    @root = root
    @generators = app_generators.dup
  end
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>这个类继承了railtie 下的configuration类:</p>

<p>``` ruby railtie/configuration.rb</p>

<p>module Rails
  class Railtie</p>

<pre><code>class Configuration
  def initialize
    @@options ||= {}
  end
end
</code></pre>

<p>  end
ene</p>

<p>```</p>

<p>看过了上面的代码之后，我们再看最后一个文件，这个文件就是在config/environment.rb 文件中的最后一行的方法:</p>

<p>``` ruby  config/environment.rb</p>

<h1>Load the rails application</h1>

<p>require File.expand_path(&lsquo;../application&rsquo;, <strong>FILE</strong>)</p>

<h1>Initialize the rails application</h1>

<p>QuillExpress::Application.initialize!</p>

<p>```</p>

<p>看一下最后一行，这一行就是我们项目的初始化过程，这个过程的实现在lib/rails/application.rb文件:</p>

<p>``` ruby rails/application.rb</p>

<p>def initialize!(group=:default) #:nodoc:
  raise &ldquo;Application has been already initialized.&rdquo; if @initialized
  run_initializers(group, self) #执行初始化
  @initialized = true
  self
end</p>

<p>```</p>

<p>接下来看看run_initializers方法在哪</p>

<p>``` ruby  initializable.rb</p>

<p>  def run_initializers(group=:default, *args)</p>

<pre><code>return if instance_variable_defined?(:@ran)
initializers.tsort_each do |initializer|
  initializer.run(*args) if initializer.belongs_to?(group)
end
@ran = true
</code></pre>

<p>  end</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Active_support_lazy_load_hooks]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/active-support-lazy-load-hooks/"/>
    <updated>2014-02-25T08:42:32+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/active-support-lazy-load-hooks</id>
    <content type="html"><![CDATA[<p>在rails的源码中经常看到有ActiveSupport.on_load这样的代码出现，于是找到代码的定义处(active_support/lazy_load_hooks.rb)中，里面的代码很简单，但是为我们提供的功能却很强大，下面我们来看一下:</p>

<p>``` ruby</p>

<p>@load_hooks = Hash.new { |h,k| h[k] = [] } #定义一个空的hash,用来存放还没有被执行的blocks
@loaded = Hash.new { |h,k| h[k] = [] } #定义一个空hash,这个空hash主要用来存放已经被加载的载体类。</p>

<p>def self.on_load(name, options = {}, &amp;block)#这个方法是见到最多的，很多我们需要将来执行的代码块儿都是通过这个方法存储的
  @loaded[name].each do |base|</p>

<pre><code>execute_hook(base, options, block)
</code></pre>

<p>  end</p>

<p>  @load_hooks[name] &lt;&lt; [block, options] #每次调用该方法时，该方法后面block要执行的动作都被暂时保存在这个变量中
end</p>

<p>def self.execute_hook(base, options, block) #这个方法主要是用来执行存储的代码用
  if options[:yield]</p>

<pre><code>block.call(base)
</code></pre>

<p>  else</p>

<pre><code>base.instance_eval(&amp;block)
</code></pre>

<p>  end
end</p>

<p>def self.run_load_hooks(name, base = Object) #执行开始的地方，当某个文件require了这个module之后，并切调用了这个方法之后，执行开始
  @loaded[name] &lt;&lt; base
  @load_hooks[name].each do |hook, options|</p>

<pre><code>execute_hook(base, options, hook)
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>下面来看一下这个azy_load_hooks用在什么地方，我们打开active_record/railtie.rb这个文件，我们会看见很多类似的代码:</p>

<!-- more -->


<p>``` ruby</p>

<p>ActiveSupport.on_load(:active_record) do
  filename = File.join(app.config.paths[&ldquo;db&rdquo;].first, &ldquo;schema_cache.dump&rdquo;)</p>

<p>  if File.file?(filename)</p>

<pre><code>cache = Marshal.load File.binread filename
if cache.version == ActiveRecord::Migrator.current_version
  self.connection.schema_cache = cache
else
  warn "Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}."
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>方法后的block是我们真正要做的额外的操作这些操作可能会延长我们的app的启动的过程，所以，我们在这里使用on_load将这些要执行的方法暂时存放在一个变量里，只有在程序需要的时候才去执行这些额外的操作，这样的话，我们的app启动的就会更快</p>

<p>最后的执行是在active_record/base.rb文件中，代码的最下面执行到了run_load_hooks方法:</p>

<p>``` ruby</p>

<p>ActiveSupport.run_load_hooks(:active_record, Base) #调用run_load_hooks，额外的操作开始执行。</p>

<p>```</p>

<p>如果你打开rails其他的railtie的话，你会发现也有azy_load_blocks方法，他们起到的作用都是一样的，即，提高我们应用启动的速度</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Active_support_autoload]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/active-support-autoload/"/>
    <updated>2014-02-25T05:43:38+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/active-support-autoload</id>
    <content type="html"><![CDATA[<p>在看rails源码的时候发现很多地方用到了autoload，意识到这个autoload是整个框架的基础方法，于是有时间看了遍里面的代码，关键的方法都定义在autoload.rb(active_support/dependencies/autoload.rb)下面我们来看下这个文件里面都做了些什么事:</p>

<p>``` ruby</p>

<p>def self.extended(base)
  base.class_eval do</p>

<pre><code>@_autoloads = {} #hash 盛放该module需要一次性require的文件,每个元素的key为大写的module的名字，value为该module对应的文件(包含路径)
@_under_path = nil #字符串，代表需要load的某个模块的路径
@_at_path = nil    #字符串，代表需要load的某个模块的路径
@_eager_autoload = false #标识位
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>以上代码，很明显，给base(某个可能extend ActiveSupport::Autoload的模块)声明了几个实例变量。</p>

<!--more-->


<p>再来看看autoload方法,这个方法是我们在rails源码中看到最多的
``` ruby</p>

<p>def autoload(const_name, path = @_at_path)
  unless path</p>

<pre><code>full = [name, @_under_path, const_name.to_s].compact.join("::")#生成一个用::隔开的字符串
path = Inflector.underscore(full)#生成要加载模块的路径 例如:ActiveSupport #=&gt; active_support
</code></pre>

<p>  end</p>

<p>  if @_eager_autoload</p>

<pre><code>@_autoloads[const_name] = path
</code></pre>

<p>  end</p>

<p>  super const_name, path #调用ruby的autoload方法，这个方法是一个懒加载，即只有用到模块中的方法或者变量的时候，才会去require该文件
end</p>

<p>```</p>

<p>接下来的几个方法:</p>

<p>``` ruby
def autoload_under(path)
  @<em>under_path, old_path = path, @</em>under_path #设置了@<em>under_path变量
  yield
ensure
  @</em>under_path = old_path
end</p>

<p>def autoload_at(path)
  @<em>at_path, old_path = path, @</em>at_path#设置了@<em>at_path变量
  yield
ensure
  @</em>at_path = old_path
end</p>

<p>def eager_autoload #这个方法用来一次性require所有所需的文件
  old_eager, @<em>eager_autoload = @</em>eager_autoload, true#设置了@<em>eager_autoload变量为true
  yield
ensure
  @</em>eager_autoload = old_eager
end
```</p>

<p>以上这三个方法都是后面跟着block的，所以这三个函数都yield了这个block，并且设置了base模块的几个基本的实例变量，这些block中的内容，如果你才看看rails源码的话，你会发现，基本上都是在里面调用了autoload方法:</p>

<p>``` ruby
autoload_under &ldquo;renderer&rdquo; do
  autoload :Renderer
  autoload :AbstractRenderer
  autoload :PartialRenderer
  autoload :TemplateRenderer
  autoload :StreamingTemplateRenderer
end</p>

<p>autoload_at &ldquo;action_view/template/resolver&rdquo; do
  autoload :Resolver
  autoload :PathResolver
  autoload :OptimizedFileSystemResolver
  autoload :FallbackFileSystemResolver
end</p>

<p>eager_autoload do
  autoload :Base
  autoload :Context
  autoload :CompiledTemplates, &ldquo;action_view/context&rdquo;
  autoload :Digestor
  autoload :Helpers
  autoload :LookupContext
  autoload :Layouts
  autoload :PathSet
  autoload :RecordIdentifier
  autoload :Rendering
  autoload :RoutingUrlFor
  autoload :Template
  autoload :ViewPaths
end</p>

<p>```</p>

<p>这个时候我们回过头来在来看 autoload方法，里面有这么一句:</p>

<p>``` ruby</p>

<p>if @<em>eager_autoload
  @</em>autoloads[const_name] = path
end</p>

<p>```
也就是说，只要我们调用了eager_autoload这个方法，我们就会设置@<em>eager_autoload值为true，并且我们还设置了@</em>autoloads这个hash，这个hash就是用来盛放我们将来需要一次性require的文件的路径</p>

<p>再来看看最重要的一个方法:</p>

<p>``` ruby</p>

<p>def eager_load!
  @_autoloads.values.each { |file| require file }
end</p>

<p>```</p>

<p>这个方法是我们最终实现饥饿加载的最终代码所在，即一次性require我们所需的所有的module文件。</p>

<p>这个autoload模块就是用来方便我们require我们所需要的module文件的,如果一个module extend了这个autoload模块的话，那么他就可以利用autoload这个方法来加载同一个module 名命名的文件加下的其他模块文件而不用制定文件的路径。还可以通过eager_autoload方法来指定这个module需要批量require 的module的名字，然后通过 eager_load!方法就可以实现一次性require多个文件，这个方法的好处是避免了我们在文件的开头写很多的require，如下面的例子所示:</p>

<p>``` ruby</p>

<p>module MyLib
  extend ActiveSupport::Autoload</p>

<p>  autoload :Model</p>

<p>  eager_autoload do</p>

<pre><code>autoload :Cache
</code></pre>

<p>  end
end</p>

<p>Then your library can be eager loaded by simply calling:</p>

<p>MyLib.eager_load!</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveSupport::Concern Source Code Analyse]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/21/hello-world/"/>
    <updated>2014-02-21T02:44:45+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/21/hello-world</id>
    <content type="html"><![CDATA[<p>1、首先我们来看个例子
``` ruby
module M
  def self.included(base)</p>

<pre><code>base.extend ClassMethods
base.send(:include, InstanceMethods)
scope :disabled, where(:disabled =&gt; true)
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end</p>

<p>  module InstanceMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```
这是一个再普通不过的module了，当某个模块(或者类)include它以后，它让目标模块(或者类)去txtend  ClassMethods 这个模块，并去include  InstanceMethods 这个模块，这样的话，目标模块(或者类)在include M 的时候，这个目标模块(或者类)就拥有了ClassMethods这个模块中定义的方法并把这些方法当作类方法，并拥有了InstanceMethods模块的方法，并把这个模块中的方法作为自己的实例方法。如果你不觉得麻烦的话，那么这种方式是可选的或者，干脆直接定义实例方法，而不定义InstanceMethods，因为在include一个module的时候，module里面定义的方法自动就为实例方法。</p>

<!-- more -->


<p>2、再来看看另外一个例子
``` ruby
module Foo
  def self.included(base)</p>

<pre><code>base.class_eval do
  def self.method_injected_by_foo
    #...对宿主做某些操作，例如增強功能等等
  end
end
</code></pre>

<p>  end
end</p>

<p>module Bar
  def self.included(base)</p>

<pre><code>base.method_injected_by_foo #这里调用了Foo这个module定义的method_injected_by_foo方法
</code></pre>

<p>  end
end</p>

<p>class Host
  include Foo
  include Bar
  #要想让让Bar被include的时候执行Foo这个module中定义的method_injected_by_foo方法，必须在include  Bar之前先要解决依赖关系，即 include Foo
end
```
上面这个例子对于大多数的使用者来说，就会很麻烦，因为我在include某个模块的时候必须解决他们的依赖关系，要知道我include的模块依赖哪些其他模块，这个对使用者来说有点困难。为了解决这个依赖的问题，貌似我们可以这样做，即将依赖关系放到module内去解决,如下:</p>

<p>```ruby
 module Foo
   def self.included(base)</p>

<pre><code> base.class_eval do
   def self.method_injected_by_foo
     #...对宿主做某些操作，例如增強功能等等
   end
 end
</code></pre>

<p>   end
 end</p>

<p> module Bar
   include Foo #在这里解决依赖问题</p>

<p>   def self.included(base)</p>

<pre><code> base.send(:do_host_something)
</code></pre>

<p>   end</p>

<p> end</p>

<p> class Host
   include Bar # 这里只需要include一个Bar，而不用关心依赖问题
 end
```
以上代码看似可以执行，但是问题是，在Foo被 Bar include的时候，对于Foo来说，此时的base为Bar，而不是 class Host，所以我们没法在Host include的时候，拿到Host中的do_host_something方法，因为它根本就不在Host中</p>

<p>3、为了解决以上讨论的两个问题，ActiveSupport::Concern出现了，对于上面的问题，你只要这样操作就可以了:</p>

<p>对于第一个问题，你可以这样解决:
``` ruby
require &lsquo;active_support/concern&rsquo;
module M
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>scope :disabled, -&gt; { where(disabled: true) }
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```</p>

<p>对于第二个问题，你可以这样解决:
``` ruby</p>

<pre><code>require 'active_support/concern'
module Foo
  extend ActiveSupport::Concern
  included do
    def self.method_injected_by_foo
      ...
    end
  end
end

module Bar
  extend ActiveSupport::Concern
  include Foo

  included do
    self.method_injected_by_foo
  end
end

class Host
  include Bar # 只include Bar就可以了，其他的我们不用关心
end
</code></pre>

<p>```</p>

<p>4、接下来，我们看看 active_support/concern 的源码是怎样来实现这些逻辑的</p>

<p>a、首先定义了一个异常类:
``` ruby
class MultipleIncludedBlocks &lt; StandardError
  def initialize</p>

<pre><code>super "Cannot define multiple 'included' blocks for a Concern"
</code></pre>

<p>  end
end
<code>
b、模块被extend的时候，为base添加一个类实例变量，并赋值为空数组，这个类实例变量是用来记录base模块(或者类)的所有依赖模块的
</code> ruby
def self.extended(base)
  base.instance_variable_set(:@_dependencies, [])
end
```
c、重写了ruby的 append_features 方法，这个append_features 是ruby Module中的方法，愿意是当一个module(a)被include 到另一个module(b)的时候，就会调用module  a 中的这个append_features方法，并且把module b 做为参数传给append_features方法，然后将module a中的常量，方法，变量添加到module b 中。</p>

<p>``` ruby
def append_features(base) #此时的base代表module b
  if base.instance_variable_defined?(:@_dependencies)</p>

<pre><code>base.instance_variable_get(:@_dependencies) &lt;&lt; self  #此时的self是module a 
return false
</code></pre>

<p>  else</p>

<pre><code>return false if base &lt; self 
@_dependencies.each { |dep| base.send(:include, dep) }  # module b 去 循环include  modulea 的依赖 module
super  # 这个super 调用的是ruby原来的 append_features 方法
base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods) #module b 去extend  module a 中定一的 ClassMethods 模块
base.class_eval(&amp;@_included_block) if instance_variable_defined?(:@_included_block)  # 为module b 动态添加一些内容(block中的内容)
</code></pre>

<p>  end
end
```</p>

<p>来看一下这个方法的具体逻辑，首先判断 module b 中是否已经有了类实例变量@<em>dependencies，如果有的话，那么将被include的module a 追加到这个变量中，如果一个module 中设置了 @</em>dependencies 这个变量 那么说明 该module 肯定extend 了active_support/concern，如果一个module中没有设置这个变量，可以肯定，该module 没有 extend  active_support/concern ，则该module是最后应用的那个module 。</p>

<p>d、重新定义included 方法，included方法是ruby module中的方法，当一个module a 被另一个module b include的时候，module a 的included 方法就会执行，并把module 作为一个参数 base 传递给该方法，我们可以在这里对base做一些inject，这里对included方法进行了重写。</p>

<p>``` ruby
def included(base = nil, &amp;block)
  if base.nil?</p>

<pre><code>raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)
@_included_block = block
</code></pre>

<p>  else</p>

<pre><code>super
</code></pre>

<p>  end
end
```</p>

<p>当module a 被module include 后，如果这个方法传递了一个base，那么就直接使用ruby module中的included方法，如果我们在include的时候，传递的是一个block，那么就将该block 转化为proc对象，并赋值给 @_included_block 变量，这个变量会在 上边的 append_features方法中使用，这个block一般是用来动态给base 添加一些方法活属性用。例如:</p>

<p>``` ruby
require &lsquo;active_support/concern&rsquo;
module M
  extend ActiveSupport::Concern</p>

<p>  included do  #这里调用included方法，我们只传递了一个block，并且这个block中用来声明一些方法，将来这些方法会成为base的类方法</p>

<pre><code>scope :disabled, -&gt; { where(disabled: true) }
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
</feed>
