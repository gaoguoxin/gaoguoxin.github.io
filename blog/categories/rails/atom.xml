<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | ruby and rails study]]></title>
  <link href="http://gaoguoxin.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://gaoguoxin.github.io/"/>
  <updated>2014-02-25T06:39:41+00:00</updated>
  <id>http://gaoguoxin.github.io/</id>
  <author>
    <name><![CDATA[naitnix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Active_support_autoload]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/active-support-autoload/"/>
    <updated>2014-02-25T05:43:38+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/active-support-autoload</id>
    <content type="html"><![CDATA[<p>在看rails源码的时候发现很多地方用到了autoload，意识到这个autoload是整个框架的基础方法，于是有时间看了遍里面的代码，关键的方法都定义在autoload.rb(active_support/dependencies/autoload.rb)下面我们来看下这个文件里面都做了些什么事:</p>

<p>``` ruby</p>

<p>def self.extended(base)
  base.class_eval do</p>

<pre><code>@_autoloads = {} #hash 盛放该module需要一次性require的文件,每个元素的key为大写的module的名字，value为该module对应的文件(包含路径)
@_under_path = nil #字符串，代表需要load的某个模块的路径
@_at_path = nil    #字符串，代表需要load的某个模块的路径
@_eager_autoload = false #标识位
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>以上代码，很明显，给base(某个可能extend ActiveSupport::Autoload的模块)声明了几个实例变量。</p>

<!--more-->


<p>再来看看autoload方法,这个方法是我们在rails源码中看到最多的
``` ruby</p>

<p>def autoload(const_name, path = @_at_path)
  unless path</p>

<pre><code>full = [name, @_under_path, const_name.to_s].compact.join("::")#生成一个用::隔开的字符串
path = Inflector.underscore(full)#生成要加载模块的路径 例如:ActiveSupport #=&gt; active_support
</code></pre>

<p>  end</p>

<p>  if @_eager_autoload</p>

<pre><code>@_autoloads[const_name] = path
</code></pre>

<p>  end</p>

<p>  super const_name, path #调用ruby的autoload方法，这个方法是一个懒加载，即只有用到模块中的方法或者变量的时候，才会去require该文件
end</p>

<p>```</p>

<p>接下来的几个方法:</p>

<p>``` ruby
def autoload_under(path)
  @<em>under_path, old_path = path, @</em>under_path #设置了@<em>under_path变量
  yield
ensure
  @</em>under_path = old_path
end</p>

<p>def autoload_at(path)
  @<em>at_path, old_path = path, @</em>at_path#设置了@<em>at_path变量
  yield
ensure
  @</em>at_path = old_path
end</p>

<p>def eager_autoload #这个方法用来一次性require所有所需的文件
  old_eager, @<em>eager_autoload = @</em>eager_autoload, true#设置了@<em>eager_autoload变量为true
  yield
ensure
  @</em>eager_autoload = old_eager
end
```</p>

<p>以上这三个方法都是后面跟着block的，所以这三个函数都yield了这个block，并且设置了base模块的几个基本的实例变量，这些block中的内容，如果你才看看rails源码的话，你会发现，基本上都是在里面调用了autoload方法:</p>

<p>``` ruby
autoload_under &ldquo;renderer&rdquo; do
  autoload :Renderer
  autoload :AbstractRenderer
  autoload :PartialRenderer
  autoload :TemplateRenderer
  autoload :StreamingTemplateRenderer
end</p>

<p>autoload_at &ldquo;action_view/template/resolver&rdquo; do
  autoload :Resolver
  autoload :PathResolver
  autoload :OptimizedFileSystemResolver
  autoload :FallbackFileSystemResolver
end</p>

<p>eager_autoload do
  autoload :Base
  autoload :Context
  autoload :CompiledTemplates, &ldquo;action_view/context&rdquo;
  autoload :Digestor
  autoload :Helpers
  autoload :LookupContext
  autoload :Layouts
  autoload :PathSet
  autoload :RecordIdentifier
  autoload :Rendering
  autoload :RoutingUrlFor
  autoload :Template
  autoload :ViewPaths
end</p>

<p>```</p>

<p>这个时候我们回过头来在来看 autoload方法，里面有这么一句:</p>

<p>``` ruby</p>

<p>if @<em>eager_autoload
  @</em>autoloads[const_name] = path
end</p>

<p>```
也就是说，只要我们调用了eager_autoload这个方法，我们就会设置@<em>eager_autoload值为true，并且我们还设置了@</em>autoloads这个hash，这个hash就是用来盛放我们将来需要一次性require的文件的路径</p>

<p>再来看看最重要的一个方法:</p>

<p>``` ruby</p>

<p>def eager_load!
  @_autoloads.values.each { |file| require file }
end</p>

<p>```</p>

<p>这个方法是我们最终实现饥饿加载的最终代码所在，即一次性require我们所需的所有的module文件。</p>

<p>这个autoload模块就是用来方便我们require我们所需要的module文件的,如果一个module extend了这个autoload模块的话，那么他就可以利用autoload这个方法来加载同一个module 名命名的文件加下的其他模块文件而不用制定文件的路径。还可以通过eager_autoload方法来指定这个module需要批量require 的module的名字，然后通过 eager_load!方法就可以实现一次性require多个文件，这个方法的好处是避免了我们在文件的开头写很多的require，如下面的例子所示:</p>

<p>``` ruby</p>

<p>module MyLib
  extend ActiveSupport::Autoload</p>

<p>  autoload :Model</p>

<p>  eager_autoload do</p>

<pre><code>autoload :Cache
</code></pre>

<p>  end
end</p>

<p>Then your library can be eager loaded by simply calling:</p>

<p>MyLib.eager_load!</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveSupport::Concern Source Code Analyse]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/21/hello-world/"/>
    <updated>2014-02-21T02:44:45+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/21/hello-world</id>
    <content type="html"><![CDATA[<p>1、首先我们来看个例子
``` ruby
module M
  def self.included(base)</p>

<pre><code>base.extend ClassMethods
base.send(:include, InstanceMethods)
scope :disabled, where(:disabled =&gt; true)
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end</p>

<p>  module InstanceMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```
这是一个再普通不过的module了，当某个模块(或者类)include它以后，它让目标模块(或者类)去txtend  ClassMethods 这个模块，并去include  InstanceMethods 这个模块，这样的话，目标模块(或者类)在include M 的时候，这个目标模块(或者类)就拥有了ClassMethods这个模块中定义的方法并把这些方法当作类方法，并拥有了InstanceMethods模块的方法，并把这个模块中的方法作为自己的实例方法。如果你不觉得麻烦的话，那么这种方式是可选的或者，干脆直接定义实例方法，而不定义InstanceMethods，因为在include一个module的时候，module里面定义的方法自动就为实例方法。</p>

<p>2、再来看看另外一个例子
``` ruby
module Foo
  def self.included(base)</p>

<pre><code>base.class_eval do
  def self.method_injected_by_foo
    #...对宿主做某些操作，例如增強功能等等
  end
end
</code></pre>

<p>  end
end</p>

<p>module Bar
  def self.included(base)</p>

<pre><code>base.method_injected_by_foo #这里调用了Foo这个module定义的method_injected_by_foo方法
</code></pre>

<p>  end
end</p>

<p>class Host
  include Foo
  include Bar
  #要想让让Bar被include的时候执行Foo这个module中定义的method_injected_by_foo方法，必须在include  Bar之前先要解决依赖关系，即 include Foo
end
```
上面这个例子对于大多数的使用者来说，就会很麻烦，因为我在include某个模块的时候必须解决他们的依赖关系，要知道我include的模块依赖哪些其他模块，这个对使用者来说有点困难。为了解决这个依赖的问题，貌似我们可以这样做，即将依赖关系放到module内去解决,如下:</p>

<p>```ruby
 module Foo
   def self.included(base)</p>

<pre><code> base.class_eval do
   def self.method_injected_by_foo
     #...对宿主做某些操作，例如增強功能等等
   end
 end
</code></pre>

<p>   end
 end</p>

<p> module Bar
   include Foo #在这里解决依赖问题</p>

<p>   def self.included(base)</p>

<pre><code> base.send(:do_host_something)
</code></pre>

<p>   end</p>

<p> end</p>

<p> class Host
   include Bar # 这里只需要include一个Bar，而不用关心依赖问题
 end
```
以上代码看似可以执行，但是问题是，在Foo被 Bar include的时候，对于Foo来说，此时的base为Bar，而不是 class Host，所以我们没法在Host include的时候，拿到Host中的do_host_something方法，因为它根本就不在Host中</p>

<p>3、为了解决以上讨论的两个问题，ActiveSupport::Concern出现了，对于上面的问题，你只要这样操作就可以了:</p>

<p>对于第一个问题，你可以这样解决:
``` ruby
require &lsquo;active_support/concern&rsquo;
module M
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>scope :disabled, -&gt; { where(disabled: true) }
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```</p>

<p>对于第二个问题，你可以这样解决:
``` ruby</p>

<pre><code>require 'active_support/concern'
module Foo
  extend ActiveSupport::Concern
  included do
    def self.method_injected_by_foo
      ...
    end
  end
end

module Bar
  extend ActiveSupport::Concern
  include Foo

  included do
    self.method_injected_by_foo
  end
end

class Host
  include Bar # 只include Bar就可以了，其他的我们不用关心
end
</code></pre>

<p>```</p>

<p>4、接下来，我们看看 active_support/concern 的源码是怎样来实现这些逻辑的</p>

<p>a、首先定义了一个异常类:
``` ruby
class MultipleIncludedBlocks &lt; StandardError
  def initialize</p>

<pre><code>super "Cannot define multiple 'included' blocks for a Concern"
</code></pre>

<p>  end
end
<code>
b、模块被extend的时候，为base添加一个类实例变量，并赋值为空数组，这个类实例变量是用来记录base模块(或者类)的所有依赖模块的
</code> ruby
def self.extended(base)
  base.instance_variable_set(:@_dependencies, [])
end
```
c、重写了ruby的 append_features 方法，这个append_features 是ruby Module中的方法，愿意是当一个module(a)被include 到另一个module(b)的时候，就会调用module  a 中的这个append_features方法，并且把module b 做为参数传给append_features方法，然后将module a中的常量，方法，变量添加到module b 中。</p>

<p>``` ruby
def append_features(base) #此时的base代表module b
  if base.instance_variable_defined?(:@_dependencies)</p>

<pre><code>base.instance_variable_get(:@_dependencies) &lt;&lt; self  #此时的self是module a 
return false
</code></pre>

<p>  else</p>

<pre><code>return false if base &lt; self 
@_dependencies.each { |dep| base.send(:include, dep) }  # module b 去 循环include  modulea 的依赖 module
super  # 这个super 调用的是ruby原来的 append_features 方法
base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods) #module b 去extend  module a 中定一的 ClassMethods 模块
base.class_eval(&amp;@_included_block) if instance_variable_defined?(:@_included_block)  # 为module b 动态添加一些内容(block中的内容)
</code></pre>

<p>  end
end
```</p>

<p>来看一下这个方法的具体逻辑，首先判断 module b 中是否已经有了类实例变量@<em>dependencies，如果有的话，那么将被include的module a 追加到这个变量中，如果一个module 中设置了 @</em>dependencies 这个变量 那么说明 该module 肯定extend 了active_support/concern，如果一个module中没有设置这个变量，可以肯定，该module 没有 extend  active_support/concern ，则该module是最后应用的那个module 。</p>

<p>d、重新定义included 方法，included方法是ruby module中的方法，当一个module a 被另一个module b include的时候，module a 的included 方法就会执行，并把module 作为一个参数 base 传递给该方法，我们可以在这里对base做一些inject，这里对included方法进行了重写。</p>

<p>``` ruby
def included(base = nil, &amp;block)
  if base.nil?</p>

<pre><code>raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)
@_included_block = block
</code></pre>

<p>  else</p>

<pre><code>super
</code></pre>

<p>  end
end
```</p>

<p>当module a 被module include 后，如果这个方法传递了一个base，那么就直接使用ruby module中的included方法，如果我们在include的时候，传递的是一个block，那么就将该block 转化为proc对象，并赋值给 @_included_block 变量，这个变量会在 上边的 append_features方法中使用，这个block一般是用来动态给base 添加一些方法活属性用。例如:</p>

<p>``` ruby
require &lsquo;active_support/concern&rsquo;
module M
  extend ActiveSupport::Concern</p>

<p>  included do  #这里调用included方法，我们只传递了一个block，并且这个block中用来声明一些方法，将来这些方法会成为base的类方法</p>

<pre><code>scope :disabled, -&gt; { where(disabled: true) }
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
</feed>
