<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | ruby and rails study]]></title>
  <link href="http://gaoguoxin.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://gaoguoxin.github.io/"/>
  <updated>2014-02-27T08:11:38+00:00</updated>
  <id>http://gaoguoxin.github.io/</id>
  <author>
    <name><![CDATA[naitnix]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rack]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/27/rack/"/>
    <updated>2014-02-27T02:25:06+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/27/rack</id>
    <content type="html"><![CDATA[<h2>Rack是什么</h2>

<blockquote><p>Dabbling in my own web framework experiments, I noticed that there is a lot of code duplication among frameworks since they essentially all do the same things. And still, every Ruby web framework developer is writing his own handlers for every webserver he wants to use. Hopefully, the framework users are satisfied with that choice.</p></blockquote>

<p>以上是rack作者Christian Neukirchen的一句话，意思是说，他在自己开发自己的ruby web framework的时候意识到了这个问题，即很多的ruby web 框架开发者在开发自己的框架的时候都在做很多重复性的工作，写很多的代码来实现一个处理器，以达到这些处理器能适应他们想要用到的每一个webserver，实际上他们写的这些处理器(handler)其实都是在做一件事就是处理http，即接受一个request并且返回一个response。</p>

<p>rack的灵感来源于phyton社区的wsgi，目标是实现一个最小化的接口来链接web framework  和 web server。rack为用ruby开发的web框架提供了一个最小化的，模块化的，并且适应性强的的接口，它用最简单的方式包装了http request 和http response，它结合并提取了web server 和 ruby web framework 之间的api 到一个call 方法里。</p>

<h2>Rack的最简单实现</h2>

<p>从上面的定义可以看出，rack是将http request 和httpresponse  提取到了一个call方法里面。这个call方法必须接受一个environment参数，这个参数格式应该是一个hash，并返回一个包含了status, headers  和 body 三部分的 一个数组，这个status 代表响应的状态，比如 200，404 500 等，headers是一个集合，包含比如说Content-Type在内的一些信息，body应该十一个字符串类型的数组。例如:</p>

<p>``` ruby</p>

<p>class HelloWorld
  def call(env)</p>

<pre><code>[200, {"Content-Type" =&gt; "text/plain"}, ["Hello world!"]]
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>可以看到 Rack 是一个应用(application),这个application 是一个object而不是一个class，这个application (object)可以响应call方法，这个call方法接受一个environment方法，并且返回一个包含status，headers和baody三个元素的数组。以上这个rack application  是我们自己手写的，我们没有依赖任何的gem，就是说，我们只要遵循rack的规范，我们就可以写出自己的rack 应用。</p>

<p>此外，我们还有rack 这个gem，rack  gem 是一个很多高级的和共用的类的集合,能够为我们开发rack应用提供很多的便利，它包含了基本的request，response，cookie，session 的实现，还有很多有用的middleware</p>

<h2>总结</h2>

<ul>
<li>Rack是一个能够运行你自己的ruby框架的框架</li>
<li>Rack提供了一个接口，让你的ruby web framework 能够链接到各种不同的支持rack的 web server ，这些server 包括 passenger、Litespeed, Mongrel, Thin, Ebb, Webrick等。</li>
<li>Rack gem 为你免费提供了 request，response，cookies，params,session等</li>
<li>Rack允许你在一个application中使用多个不同的框架， <a href="http://m.onkey.org/2008/11/10/rails-meets-sinatra">Rails and sinatra integration</a>是一个很好的例子。</li>
<li>Rack提供了中间件(middleware),这个中间件就类似与rails的 前置/后置 过滤器，而且这个中间件可以在不同的rack application中重复使用</li>
</ul>


<h2>Other example</h2>

<p>``` ruby  another rack application</p>

<p>require &lsquo;rubygems&rsquo;
require &lsquo;rack&rsquo;</p>

<p>class HelloWorld
  def call(env)</p>

<pre><code>[200, {"Content-Type" =&gt; "text/html"}, "Hello Rack!"]
</code></pre>

<p>  end
end</p>

<p>Rack::Handler::Mongrel.run HelloWorld.new, :Port => 9292</p>

<p>```</p>

<p>上面的代码传递了一个 HelloWord类的实例 到 mongorel  Rack handler ，并且启动端口9292作为服务端口，这个HelloWorld的实例遵循了rack 的基本原则:
*  能够相应call方法，并且这个call方法接受一个environment作为参数
*  这个call方法返回了[http_status_code, response_headers_hash, body]格式的数组</p>

<p>如果我们将上面代码最后一行简单的改写成这样:
``` ruby</p>

<p>Rack::Handler::WEBrick.run(HelloRack.new, :Port => 9292)</p>

<p>```</p>

<p>向上面这样，我们就可以简单的将webserver 从mongrel 转换到了webrick。如果你这个时候打开浏览器，并访问localhost:9292,你就可以看到页面上输出 Hello Rack!的字样。</p>

<p>我们知道，一个object必须要有call方法才有可能成为rack application，那么在ruby里面，一个proc 对象就有一个call方法，那么是不是可以使用proc对象来构造我们的rack application 呢?看一下下面这个实现:</p>

<p>``` ruby</p>

<p>require &lsquo;rubygems&rsquo;
require &lsquo;rack&rsquo;</p>

<p>Rack::Handler::Mongrel.run proc {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, &ldquo;Hello Rack!&rdquo;]}, :Port => 9292</p>

<p>```</p>

<p>看，向上面这个例子，我们使用了proc对象来创建我们的rack application 应用，如果我们访问我们的浏览器地址 localhost:9292,我们一样可以看到正常的输出。</p>

<p>另外一个常用的模式还有:</p>

<p>``` ruby</p>

<p>require &lsquo;rubygems&rsquo;
require &lsquo;rack&rsquo;</p>

<p>def application(env)
  [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, &ldquo;Hello Rack!&rdquo;]
end</p>

<p>Rack::Handler::Mongrel.run method(:application), :Port => 9292</p>

<p>```</p>

<p>这种模式中，method方法的接收者是main，method方法会查找这个main对象的application方法，并执行这个方法。</p>

<h2>Rackup</h2>

<p>rack 这个gem 为我们提供了很多有用的工具，能够让我们在开发rack应用的时候更轻松，rackup就是其中之一。在上面的例子中，我们直接使用了mongrel handler Rack::Handler::Mongrel  和 webrick handler Rack::Handler::Mongrel 而且是直接将端口号写了进去，如果我们使用rackup的话，这些事情将会变得非常简单和自然，但是我们必须提供一个叫做config.ru的文件。对于上面的例子，我们可以这样：</p>

<p>``` ruby config.ru</p>

<p>run Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, &ldquo;Hello Rack!&rdquo;]}</p>

<p>```</p>

<p>然后，我们就可以在命令行直接输入 rackup  congig.ru  这样就能启动我们的rack application了，默认启用的端口是9292，但是我们可以通过 -p参数来改变启动的端口</p>

<h2>Rack Builder</h2>

<p>在上面的例子中，我们使用了rackup，实际上当我们使用rackup启动我们的应用的时候，rackup把config文件转换成了Rackup::Builder的一个实例。</p>

<h3>what&rsquo;s Rack::Builder</h3>

<p>Rack::Builder是一个能够将各种Rack middlewares 和application 整合到一起并转换为一个rack application的东西。</p>

<h3>example</h3>

<p>比如说，我们的rack application 叫 infinity:
``` ruby
infinity = Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, env.inspect]}
Rack::Handler::Mongrel.run infinity, :Port => 9292</p>

<p>```</p>

<p>如上代码所示，这个infinity所做的事就是将这个environment参数的所有内容返回到浏览器。</p>

<p>你需要关注Rack::Builder的三个实例方法:</p>

<ul>
<li><p>Rack::Builder#run</p></li>
<li><p>Rack::Builder#use</p></li>
<li><p>Rack::Builder#map</p></li>
</ul>


<p>Rack::Builder#run 指定你要用Rack::Builder包装的rack application的应用，并转换这个Rack::application为Rack::Builder的实例：
``` ruby</p>

<p>infinity = Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, env.inspect]}
builder = Rack::Builder.new
builder.run infinity
Rack::Handler::Mongrel.run builder, :Port => 9292</p>

<p>```</p>

<p>或者你也可以ruby社区的惯例方式:
``` ruby</p>

<p>infinity = Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, env.inspect]}
builder = Rack::Builder.new do
  run infinity
end
Rack::Handler::Mongrel.run builder, :Port => 9292</p>

<p>```</p>

<p>Rack::Builder#use 这个方法是用来添加一个middleware 到rack application 的，你可以把这个middleware当作是一个前置/后置 过滤器。 Rack gem  有许多有用的middleware，比如说，Rack::CommonLogger，这个middleware是用来帮助我们打印apache格式的日志的，如果我们想给我们的rack application 添加这个middleware的话，我们可以这样:
``` ruby</p>

<p>infinity = Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, env.inspect]}
builder = Rack::Builder.new do
  use Rack::CommonLogger
  run infinity
end
Rack::Handler::Mongrel.run builder, :Port => 9292</p>

<p>```</p>

<p>Rack::Builder#map 通过这个方法，我们可以挂在很多的middleware到我们的rack application 中指定的某个url或者其子url中,比如说，你想让用户在访问/version(比如说 /version,/version/whatever，但是不是/versionsomething)，你想要做一些特殊的事情:</p>

<p>``` ruby</p>

<p>infinity = Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, env.inspect]}
builder = Rack::Builder.new do
  use Rack::CommonLogger</p>

<p>  map &lsquo;/&rsquo; do</p>

<pre><code>run infinity
</code></pre>

<p>  end</p>

<p>  map &lsquo;/version&rsquo; do</p>

<pre><code>run Proc.new {|env| [200, {"Content-Type" =&gt; "text/html"}, "infinity 0.1"] }
</code></pre>

<p>  end
end
Rack::Handler::Mongrel.run builder, :Port => 9292</p>

<p>```</p>

<p>现在，如果你访问localhost:9292的话，你会发现页面返回的是 env的信息，如果你访问的是localhost:9292/version的话，将会返回 infinity 0.1，如果你访问localhost:9292/versionsomething的话，仍然返回env的信息</p>

<h3>nesting  maps</h3>

<p>如果你想给你的rack application 路由更多的选择的话，你可以使用以下这种方法:</p>

<p>``` ruby</p>

<p>infinity = Proc.new {|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/html&rdquo;}, env.inspect]}
builder = Rack::Builder.new do
  use Rack::CommonLogger</p>

<p>  map &lsquo;/&rsquo; do</p>

<pre><code>run infinity
</code></pre>

<p>  end</p>

<p>  map &lsquo;/version&rsquo; do</p>

<pre><code>map '/' do
  run Proc.new {|env| [200, {"Content-Type" =&gt; "text/html"}, "infinity 0.1"] }
end

map '/last' do
  run Proc.new {|env| [200, {"Content-Type" =&gt; "text/html"}, "infinity beta 0.0"] }
end
</code></pre>

<p>  end
end
Rack::Handler::Mongrel.run builder, :Port => 9292</p>

<p>```</p>

<h3>write your own  middleware</h3>

<p>``` ruby  myrackmiddleware.rb</p>

<p>class MyRackMiddleware
  def initialize(appl)</p>

<pre><code>@appl = appl
</code></pre>

<p>  end
  def call(env)</p>

<pre><code>status, headers, body = @appl.call(env)
append_s = "... greetings from RubyLearning!!"
new_body = ""
body.each { |string| new_body &lt;&lt; " " &lt;&lt; string }
new_body &lt;&lt; " " &lt;&lt; append_s
[status, headers, [new_body]]
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>``` ruby  my_app.rb</p>

<p>class MyApp
  def call(env)</p>

<pre><code>[200, {"Content-Type" =&gt; "text/html"}, ["Hello Rack Participants from across the globe"]] 
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>``` ruby  config.ru</p>

<p>require &lsquo;./my_app&rsquo;
require &lsquo;./myrackmiddleware&rsquo;
use Rack::Reloader
use MyRackMiddleware
run MyApp.new</p>

<p>```</p>

<h3>another middle ware</h3>

<p>``` ruby  my_middleware.rb</p>

<p>module MyMiddleware
  class Hello</p>

<pre><code>def initialize(app)
  @app = app
end
def call(env)
  if env['PATH_INFO'] == '/hello'
    [200, {"Content-Type" =&gt; "text/plain"}, ["Hello from the middleware!"]]
  else
    # forward the request
    @app.call(env)
  end
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>``` ruby config.ru</p>

<p>require &lsquo;./my_middleware&rsquo;
use MyMiddleware::Hello # this comes in between
run Proc.new{|env| [200, {&ldquo;Content-Type&rdquo; => &ldquo;text/plain&rdquo;}, [&lsquo;Try accessing visiting /hello&rsquo;]] }</p>

<p>```</p>

<h2>最后</h2>

<p><img src="/images/rack.jpeg" alt="rack image" /></p>

<p>上图是rack的一张简易图，可一看出，rack包含了adapters 用来链接一系列的ruby web framework，还包含handlers 用来链接支持rack的webserver。在handlers和adapters中间是一系列的middleware。middleware的背后原理就是在request到达server之前对request做一些处理，在response返回到framework之前对response做一些处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails_initialize]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/rails-initialize/"/>
    <updated>2014-02-25T09:26:57+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/rails-initialize</id>
    <content type="html"><![CDATA[<p>我们经常在我们的rails项目的根目录执行这样的操作，比如:</p>

<p>``` ruby</p>

<p>rails s  #=> 启动本地服务器，让我们的项目跑起来
rails c  #=> 启动console
rails db #=> 启动我们的database终端</p>

<p>```</p>

<p>上面的命令你可能已经再熟悉不过了，但是你想过没有，为什么rails命令可以执行?难道rails是我们系统的命令么?这就设计我本文要讲的，rails的启动流成了。在你的终端输入</p>

<p>``` bash</p>

<p>which rails #=> /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin/rails (这个路径是你的rails可执行文件的所在路径)</p>

<p>echo $PATH  #=> /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin (我们的系统环境变量)</p>

<p>```</p>

<!-- more -->


<p>以上输出说明，我们的rails命令是一个可执行脚本文件，并且这个脚本文件被我们添加到了系统的环境变量。下面我们来看看这个脚本的具体内容:</p>

<p>``` ruby  /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin/rails</p>

<h1>!/usr/bin/env ruby  这句话的意思是使用系统环境变量中的ruby解释器，与shell中的  #!/usr/bin/bash不同</h1>

<p>#</p>

<h1>This file was generated by RubyGems.</h1>

<p>#</p>

<h1>The application &lsquo;railties&rsquo; is installed as part of a gem, and</h1>

<h1>this file is here to facilitate running it.</h1>

<p>#</p>

<p>require &lsquo;rubygems&rsquo;  #加载rubygems</p>

<p>version = &ldquo;>= 0&rdquo;</p>

<p>if ARGV.first =~ /^<em>(.*)</em>$/ and Gem::Version.correct? $1 then
  version = $1
  ARGV.shift
end</p>

<p>gem &lsquo;railties&rsquo;, version #导入railties这个gem，这是rails中的核心概念
load Gem.bin_path(&lsquo;railties&rsquo;, &lsquo;rails&rsquo;, version)  #加载railties目录下的rails</p>

<p>```</p>

<p>如果我们在我们项目的根目录输入 bundle show rails 看一下我们的rails装在了哪里，他会告诉我们类似下面这样的一个路径:</p>

<p>``` ruby</p>

<p>/home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/rails-3.2.16</p>

<p>```</p>

<p>如果我们进入这个目录查看里面的内容，你会发现里面是空的，这是怎么回事?</p>

<p>``` ruby</p>

<p>cd /home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/rails-3.2.16</p>

<p>ls # => 空的，没有任何内容</p>

<p>```</p>

<p>自rails3起，rails的所有的源代码都放到了railties 里面，如果我们回到 上面一个目录，你会发现有一个对应的 railties-3.2.16目录:</p>

<p>``` ruby</p>

<p>cd ../</p>

<p>ls #=> railties-3.2.16</p>

<p>cd railties-3.2.16</p>

<p>ls -l</p>

<p>drwxrwxr-x 2 naitnix naitnix 4096 Feb  8 08:56 bin
-rw-r&mdash;r&mdash; 1 naitnix naitnix 4966 Dec  9 05:44 CHANGELOG.md
drwxrwxr-x 6 naitnix naitnix 4096 Dec  9 05:44 guides
drwxrwxr-x 3 naitnix naitnix 4096 Dec  9 05:44 lib
-rw-r&mdash;r&mdash; 1 naitnix naitnix  765 Dec  9 05:44 README.rdoc</p>

<p>```</p>

<p>如果你从github  clone了rails的源码的话，你会发现他的代码结构与我们上面的目录类似，只是多了几个rails的组件:</p>

<p>``` ruby</p>

<p>drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionmailer
drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionpack
drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionview
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activemodel
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activerecord
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activesupport
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 ci
-rw-rw-r&mdash; 1 naitnix naitnix 1203 Feb 20 09:10 CONTRIBUTING.md
-rw-rw-r&mdash; 1 naitnix naitnix 2203 Feb 20 09:10 Gemfile
drwxrwxr-x 7 naitnix naitnix 4096 Feb 20 09:10 guides
-rw-rw-r&mdash; 1 naitnix naitnix  524 Feb 20 09:10 install.rb
-rw-rw-r&mdash; 1 naitnix naitnix   51 Feb 20 09:10 load_paths.rb
-rw-rw-r&mdash; 1 naitnix naitnix 1159 Feb 20 09:10 rails.gemspec
-rw-rw-r&mdash; 1 naitnix naitnix   10 Feb 20 09:10 RAILS_VERSION
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 railties
-rw-rw-r&mdash; 1 naitnix naitnix 2844 Feb 20 09:10 Rakefile
-rw-rw-r&mdash; 1 naitnix naitnix 4029 Feb 20 09:10 README.md
-rw-rw-r&mdash; 1 naitnix naitnix 7671 Feb 20 09:10 RELEASING_RAILS.rdoc
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 tasks
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 tools
-rw-rw-r&mdash; 1 naitnix naitnix  158 Feb 20 09:10 version.rb</p>

<p>```</p>

<p>你会看到上面的列表中有个railties目录，这个目录就是我们上面说的rails启动流程的源码目录，让我们进入这个目录看看:</p>

<p>``` ruby</p>

<p>drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 bin
-rw-rw-r&mdash; 1 naitnix naitnix 8898 Feb 20 09:10 CHANGELOG.md
drwxrwxr-x 3 naitnix naitnix 4096 Feb 20 09:10 lib
-rw-rw-r&mdash; 1 naitnix naitnix 1072 Feb 20 09:10 MIT-LICENSE
-rw-rw-r&mdash; 1 naitnix naitnix 1028 Feb 20 09:10 railties.gemspec
-rw-rw-r&mdash; 1 naitnix naitnix 1296 Feb 20 09:10 Rakefile
-rw-rw-r&mdash; 1 naitnix naitnix 3382 Feb 20 09:10 RDOC_MAIN.rdoc
-rw-rw-r&mdash; 1 naitnix naitnix  803 Feb 20 09:10 README.rdoc
drwxrwxr-x 9 naitnix naitnix 4096 Feb 20 09:10 test</p>

<p>```</p>

<p>里面有两个目录我们需要关心，一个是bin，另一个是lib，我们在这篇文章开始说的，rails可执行文件要加载一个railties目录下的rails可执行文件，这个rails可执行文件就在这个bin目录。lib目录，里面有个rails目录，这个目录里的代码才使我们真正的启动相关的代码所在:</p>

<p>``` ruby</p>

<p>-rw-rw-r&mdash; 1 naitnix naitnix   211 Feb 20 09:10 all.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 api
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 application
-rw-rw-r&mdash; 1 naitnix naitnix   463 Feb 20 09:10 application_controller.rb
-rw-rw-r&mdash; 1 naitnix naitnix 14732 Feb 20 09:10 application.rb
-rw-rw-r&mdash; 1 naitnix naitnix  1950 Feb 20 09:10 app_rails_loader.rb
-rw-rw-r&mdash; 1 naitnix naitnix   857 Feb 20 09:10 backtrace_cleaner.rb
-rw-rw-r&mdash; 1 naitnix naitnix   381 Feb 20 09:10 cli.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2087 Feb 20 09:10 code_statistics_calculator.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2836 Feb 20 09:10 code_statistics.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 commands
-rw-rw-r&mdash; 1 naitnix naitnix   328 Feb 20 09:10 commands.rb
-rw-rw-r&mdash; 1 naitnix naitnix  3619 Feb 20 09:10 configuration.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 console
-rw-rw-r&mdash; 1 naitnix naitnix   500 Feb 20 09:10 deprecation.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 engine
-rw-rw-r&mdash; 1 naitnix naitnix 24556 Feb 20 09:10 engine.rb
drwxrwxr-x 9 naitnix naitnix  4096 Feb 20 09:10 generators
-rw-rw-r&mdash; 1 naitnix naitnix  9853 Feb 20 09:10 generators.rb
-rw-rw-r&mdash; 1 naitnix naitnix   588 Feb 20 09:10 info_controller.rb
-rw-rw-r&mdash; 1 naitnix naitnix  3129 Feb 20 09:10 info.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2276 Feb 20 09:10 initializable.rb
-rw-rw-r&mdash; 1 naitnix naitnix  2175 Feb 20 09:10 mailers_controller.rb
-rw-rw-r&mdash; 1 naitnix naitnix  5664 Feb 20 09:10 paths.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 rack
-rw-rw-r&mdash; 1 naitnix naitnix   190 Feb 20 09:10 rack.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 railtie
-rw-rw-r&mdash; 1 naitnix naitnix  7467 Feb 20 09:10 railtie.rb
-rw-rw-r&mdash; 1 naitnix naitnix   985 Feb 20 09:10 rubyprof_ext.rb
-rw-rw-r&mdash; 1 naitnix naitnix   302 Feb 20 09:10 ruby_version_check.rb
-rw-rw-r&mdash; 1 naitnix naitnix  4456 Feb 20 09:10 source_annotation_extractor.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 tasks
-rw-rw-r&mdash; 1 naitnix naitnix   188 Feb 20 09:10 tasks.rb
drwxrwxr-x 4 naitnix naitnix  4096 Feb 20 09:10 templates
-rw-rw-r&mdash; 1 naitnix naitnix  1218 Feb 20 09:10 test_help.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 test_unit
-rw-rw-r&mdash; 1 naitnix naitnix   158 Feb 20 09:10 version.rb
-rw-rw-r&mdash; 1 naitnix naitnix   150 Feb 20 09:10 welcome_controller.rb</p>

<p>```</p>

<p>如果我们看见一些以Rails开头的路径，多半指的是这个rails目录。</p>

<p>好，介绍完了rails的源码目录结构，我们接着我们开头的部分讲，当我们在终端输入rails 命令后，系统会到环境变量的目录中查找到rails可执行文件，并利用环境变量中的ruby解释器去解释这个文件，那么我们在前面看到了，这个文件主要做了两件是:第一时间在rubygems,第二就是 load了rails源码目录(bin/rails)中的rails命令文件，那么我们来看看这个rails可执行文件中到底做了哪些事:</p>

<p>``` ruby railties/bin/rails</p>

<h1>!/usr/bin/env ruby</h1>

<p>if File.exists?(File.join(File.expand_path(&lsquo;../../..&rsquo;, <strong>FILE</strong>), &lsquo;.git&rsquo;))
  railties_path = File.expand_path(&lsquo;../../lib&rsquo;, <strong>FILE</strong>)
  $:.unshift(railties_path)
end
require &ldquo;rails/cli&rdquo;</p>

<p>```</p>

<p>这个文件主要是require了 /home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.16/lib/rails/cli.rb这个文件，所以，让我们来看看这个cli.rb文件到底做了写什么</p>

<p>``` ruby lib/rails/cli.rb</p>

<p>require &lsquo;rails/app_rails_loader&rsquo;</p>

<h1>If we are inside a Rails application this method performs an exec and thus</h1>

<h1>the rest of this script is not run.</h1>

<p>Rails::AppRailsLoader.exec_app_rails</p>

<p>require &lsquo;rails/ruby_version_check&rsquo;
Signal.trap(&ldquo;INT&rdquo;) { puts; exit(1) }</p>

<p>if ARGV.first == &lsquo;plugin&rsquo;
  ARGV.shift
  require &lsquo;rails/commands/plugin&rsquo;
else
  require &lsquo;rails/commands/application&rsquo;
end</p>

<p>```</p>

<p>这个文件主要做了这么几件事:</p>

<ul>
<li>require 了 rails 目录下的app_rails_loader文件</li>
<li>执行exec_app_rails方法</li>
<li>做ruby版本的检查</li>
<li>判断rails命令后面的参数，如果跟的是plugin那么require rails/commands/plugin这个文件，否则的话，require rails/commands/application</li>
</ul>


<p>接下来，我们看看这个app_rails_loader文件中的exec_app_rails方法:</p>

<p>``` ruby app_rails_loader.rb</p>

<p>RUBY = Gem.ruby  #定义常量
EXECUTABLES = [&lsquo;bin/rails&rsquo;, &lsquo;script/rails&rsquo;]#rails可执行文件的目录</p>

<p>def self.exec_app_rails
  original_cwd = Dir.pwd</p>

<p>  loop do</p>

<pre><code>if exe = find_executable
  contents = File.read(exe)  #contents为bin/rails或者script/rails

  if contents =~ /(APP|ENGINE)_PATH/#如果contents为script/rails，则表示我们当前执行rails命令的目录是我们项目的根目录
    exec RUBY, exe, *ARGV执行script/rails命令
    break # non reachable, hack to be able to stub exec in the test suite
  elsif exe.end_with?('bin/rails') &amp;&amp; contents.include?('This file was generated by Bundler')
    #rails4 里面，移除了script目录，添加了bin目录，并将rails，bundle，rake等命令放到了这个bin目录
    $stderr.puts(BUNDLER_WARNING)
    Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))#设置常量 APP_PATH
    require File.expand_path('../boot', APP_PATH) #require  boot.rb
    require 'rails/commands' # require lib/rails/commands.rb文件
    break
  end
end

# If we exhaust the search there is no executable, this could be a
# call to generate a new application, so restore the original cwd.
Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

# Otherwise keep moving upwards in search of an executable.
Dir.chdir('..')
</code></pre>

<p>  end
end</p>

<p>def self.find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end</p>

<p>```</p>

<p>那么来看看这个script/rails(或者bin/rails)文件里都做了哪些事:</p>

<p>``` ruby script/rails(bin/rails)</p>

<p>APP_PATH = File.expand_path(&lsquo;../../config/application&rsquo;,  <strong>FILE</strong>)#设置常量 APP_PATH
require File.expand_path(&lsquo;../../config/boot&rsquo;,  <strong>FILE</strong>)#require  boot.rb
require &lsquo;rails/commands&rsquo;# require lib/rails/commands.rb文件</p>

<p>```</p>

<p>看看项目目录中的config/boot.rb文件的内容:</p>

<p>``` ruby config/boot.rb</p>

<h1>Set up gems listed in the Gemfile.</h1>

<p>ENV[&lsquo;BUNDLE_GEMFILE&rsquo;] ||= File.expand_path(&lsquo;../../Gemfile&rsquo;, <strong>FILE</strong>)</p>

<p>require &lsquo;bundler/setup&rsquo; if File.exists?(ENV[&lsquo;BUNDLE_GEMFILE&rsquo;])</p>

<p>```</p>

<p>这个文件的内容很简单，load  Gemfile文件并run bundler。接下来我们看一下 railties/lib/rails/commands.rb文件:</p>

<p>``` ruby railties/lib/rails/commands.rb</p>

<p>ARGV &lt;&lt; &lsquo;&mdash;help&rsquo; if ARGV.empty?</p>

<p>aliases = {  #设置了几个常用的命令别名
  &ldquo;g&rdquo;  => &ldquo;generate&rdquo;,
  &ldquo;d&rdquo;  => &ldquo;destroy&rdquo;,
  &ldquo;c&rdquo;  => &ldquo;console&rdquo;,
  &ldquo;s&rdquo;  => &ldquo;server&rdquo;,
  &ldquo;db&rdquo; => &ldquo;dbconsole&rdquo;,
  &ldquo;r&rdquo;  => &ldquo;runner&rdquo;
}</p>

<p>command = ARGV.shift
command = aliases[command] || command</p>

<p>require &lsquo;rails/commands/commands_tasks&rsquo;</p>

<p>Rails::CommandsTasks.new(ARGV).run_command!(command) #执行命令方法</p>

<p>```</p>

<p>上面的执行命令的方法在rails/commands/commands_tasks.rb文件，我们来看看:</p>

<p>``` ruby rails/commands/commands_tasks.rb</p>

<p>module Rails
  # This is a class which takes in a rails command and initiates the appropriate
  # initiation sequence.
  #
  # Warning: This class mutates ARGV because some commands require manipulating
  # it before they are run.
  class CommandsTasks # :nodoc:</p>

<pre><code>attr_reader :argv

HELP_MESSAGE = &lt;&lt;-EOT
</code></pre>

<p>Usage: rails COMMAND [ARGS]</p>

<p>The most common rails commands are:
 generate    Generate new code (short-cut alias: &ldquo;g&rdquo;)
 console     Start the Rails console (short-cut alias: &ldquo;c&rdquo;)
 server      Start the Rails server (short-cut alias: &ldquo;s&rdquo;)
 dbconsole   Start a console for the database specified in config/database.yml</p>

<pre><code>         (short-cut alias: "db")
</code></pre>

<p> new         Create a new Rails application. &ldquo;rails new my_app&rdquo; creates a</p>

<pre><code>         new application called MyApp in "./my_app"
</code></pre>

<p>In addition to those, there are:
 application  Generate the Rails application code
 destroy      Undo code generated with &ldquo;generate&rdquo; (short-cut alias: &ldquo;d&rdquo;)
 plugin new   Generates skeleton for developing a Rails plugin
 runner       Run a piece of code in the application environment (short-cut alias: &ldquo;r&rdquo;)</p>

<p>All commands can be run with -h (or &mdash;help) for more information.
EOT</p>

<pre><code>COMMAND_WHITELIST = %(plugin generate destroy console server dbconsole application runner new version help)

def initialize(argv)
  @argv = argv
end

def run_command!(command)
  command = parse_command(command)
  if COMMAND_WHITELIST.include?(command)
    send(command)
  else
    write_error_message(command)
  end
end

def plugin
  require_command!("plugin")
end

def generate
  generate_or_destroy(:generate)
end

def destroy
  generate_or_destroy(:destroy)
end

def console
  require_command!("console")
  options = Rails::Console.parse_arguments(argv)

  # RAILS_ENV needs to be set before config/application is required
  ENV['RAILS_ENV'] = options[:environment] if options[:environment]

  # shift ARGV so IRB doesn't freak
  shift_argv!

  require_application_and_environment!
  Rails::Console.start(Rails.application, options)
end

def server
  set_application_directory!
  require_command!("server")

  Rails::Server.new.tap do |server|
    # We need to require application after the server sets environment,
    # otherwise the --environment option given to the server won't propagate.
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  end
end

def dbconsole
  require_command!("dbconsole")
  Rails::DBConsole.start
end

def application
  require_command!("application")
end

def runner
  require_command!("runner")
end

def new
  if %w(-h --help).include?(argv.first)
    require_command!("application")
  else
    exit_with_initialization_warning!
  end
end

def version
  argv.unshift '--version'
  require_command!("application")
end

def help
  write_help_message
end

private

  def exit_with_initialization_warning!
    puts "Can't initialize a new Rails application within the directory of another, please change to a non-Rails directory first.\n"
    puts "Type 'rails' for help."
    exit(1)
  end

  def shift_argv!
    argv.shift if argv.first &amp;&amp; argv.first[0] != '-'
  end

  def require_command!(command)
    require "rails/commands/#{command}"
  end

  def generate_or_destroy(command)
    require 'rails/generators'
    require_application_and_environment!
    Rails.application.load_generators
    require "rails/commands/#{command}"
  end

  # Change to the application's path if there is no config.ru file in current directory.
  # This allows us to run `rails server` from other directories, but still get
  # the main config.ru and properly set the tmp directory.
  def set_application_directory!
    Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exist?(File.expand_path("config.ru"))
  end

  def require_application_and_environment!
    require APP_PATH
    Rails.application.require_environment!
  end

  def write_help_message
    puts HELP_MESSAGE
  end

  def write_error_message(command)
    puts "Error: Command '#{command}' not recognized"
    if %x{rake #{command} --dry-run 2&gt;&amp;1 } &amp;&amp; $?.success?
      puts "Did you mean: `$ rake #{command}` ?\n\n"
    end
    write_help_message
    exit(1)
  end

  def parse_command(command)
    case command
    when '--version', '-v'
      'version'
    when '--help', '-h'
      'help'
    else
      command
    end
  end
</code></pre>

<p>  end
end</p>

<p>```
看一下server这个方法，首先跳转到项目根目录，紧接着require commonds/server.rb这个文件，接着，new了一个Rails::Server的实例并启动这个server，接下来我们看看server.rb的内容：</p>

<p>``` ruby  server.rb</p>

<p>class Server &lt; ::Rack::Server  #继承了Rack::Server，说明我们的rails应用也是一个Rack application
  def initialize(*)</p>

<pre><code>super
set_environment
</code></pre>

<p>  end</p>

<p>  def set_environment</p>

<pre><code>ENV["RAILS_ENV"] ||= options[:environment]
</code></pre>

<p>  end</p>

<p>  def start   # 重写了Rack::Server的start方法</p>

<pre><code>print_boot_information
trap(:INT) { exit }
create_tmp_directories
log_to_stdout if options[:log_stdout]

super #调用Rack::Server的start方法
</code></pre>

<p>  ensure</p>

<pre><code># The '-h' option calls exit before @options is set.
# If we call 'options' with it unset, we get double help banners.
puts 'Exiting' unless @options &amp;&amp; options[:daemonize]
</code></pre>

<p>  end</p>

<p>  def print_boot_information</p>

<pre><code>url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
puts "=&gt; Booting #{ActiveSupport::Inflector.demodulize(server)}"
puts "=&gt; Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
puts "=&gt; Run `rails server -h` for more startup options"

if options[:Host].to_s.match(/0\.0\.0\.0/)
  puts "=&gt; Notice: server is listening on all interfaces (#{options[:Host]}). Consider using 127.0.0.1 (--binding option)"
end

puts "=&gt; Ctrl-C to shutdown server" unless options[:daemonize]
</code></pre>

<p>  end</p>

<p>  def create_tmp_directories</p>

<pre><code>%w(cache pids sessions sockets).each do |dir_to_make|
  FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
end
</code></pre>

<p>  end</p>

<p>  def log_to_stdout</p>

<pre><code>wrapped_app # touch the app so the logger is set up

console = ActiveSupport::Logger.new($stdout)
console.formatter = Rails.logger.formatter
console.level = Rails.logger.level

Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
</code></pre>

<p>  end
end</p>

<p>def default_options  #重写了Rack的default_options，这里你可以修改端口号，设置启动环境的优先级，及pid文件位置和config.ru文件的路径
  super.merge({</p>

<pre><code>Port:               3000,
DoNotReverseLookup: true,
environment:        (ENV['RAILS_ENV'] || ENV['RACK_ENV'] || "development").dup,
daemonize:          false,
debugger:           false,
pid:                File.expand_path("tmp/pids/server.pid"),
config:             File.expand_path("config.ru")
</code></pre>

<p>  })
end</p>

<p>```
可以看到这个server继承了Rack::Server，说明，我们的rails 项目也是一个Rack application, rack  application  在启动的时候会去寻找一个叫做config.ru的文件:</p>

<p>``` ruby</p>

<p>require ::File.expand_path(&lsquo;../config/environment&rsquo;,  <strong>FILE</strong>)
run Rails.application</p>

<p>```</p>

<p>这个文件 require了config/enviromnent.rb 文件，并启动我们的application，这样我们的server就启动起来了。那么我们的服务启动的时候是怎么加载我们的项目的呢，让我们看一下 config/environment.rb文件:</p>

<p>``` ruby config/environment.rb</p>

<h1>Load the Rails application.</h1>

<p>require File.expand_path(&lsquo;../application&rsquo;, <strong>FILE</strong>)</p>

<h1>Initialize the Rails application.</h1>

<p>R4pro::Application.initialize!</p>

<p>```</p>

<p>看上面的代码，这个文件只做了两件事:加载application.rb 文件 初始化我们的项目。我们先来看看这个application.rb文件:</p>

<p>``` ruby config/application.rb</p>

<p>require File.expand_path(&lsquo;../boot&rsquo;, <strong>FILE</strong>)</p>

<p>require &lsquo;rails/all&rsquo;</p>

<h1>Require the gems listed in Gemfile, including any gems</h1>

<h1>you&rsquo;ve limited to :test, :development, or :production.</h1>

<p>Bundler.require(:default, Rails.env)</p>

<p>module R4pro
  class Application &lt; Rails::Application</p>

<pre><code># Settings in config/environments/* take precedence over those specified here.
# Application configuration should go into files in config/initializers
# -- all .rb files in that directory are automatically loaded.

# Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
# Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
# config.time_zone = 'Central Time (US &amp; Canada)'

# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
</code></pre>

<p>  end
end</p>

<p>```
这个文件的第一行，require  boot.rb 文件，这个文件我们在上面说过，就是load Gemfile文件，并run  bundler 。紧接着第二行，require 了 railties/lib/rails/all.rb文件，这个all文件的内容:</p>

<p>``` ruby   all.rb</p>

<p>require &ldquo;rails&rdquo;</p>

<p>%w(
  active_record
  action_controller
  action_view
  action_mailer
  rails/test_unit
  sprockets
).each do |framework|
  begin</p>

<pre><code>require "#{framework}/railtie"
</code></pre>

<p>  rescue LoadError
  end
end</p>

<p>```</p>

<p>第一行，require了 lib/rails.rb文件，接下来，加载rails的各个模块下的railtie文件。接下来继续看config/application.rb</p>

<p>``` ruby application.rb</p>

<p>module R4pro
  class Application &lt; Rails::Application</p>

<pre><code># Settings in config/environments/* take precedence over those specified here.
# Application configuration should go into files in config/initializers
# -- all .rb files in that directory are automatically loaded.

# Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
# Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
# config.time_zone = 'Central Time (US &amp; Canada)'

# The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
# config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
# config.i18n.default_locale = :de
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>这个 class Application 继承自 Rails::Application，这个class将会在Rackup 文件中被传递到Rack server。我们再来看看Rails::Application</p>

<p>``` ruby  rails/application.rb</p>

<p>class Application &lt; Engine
  def inherited(base)</p>

<pre><code>super #调用Engine的super
Rails.application ||= base.instance #这个Rails是在lib/rails.rb中定义的一个module，这个application是它的一个attributes
</code></pre>

<p>  end</p>

<p>  def config  #这个及时我们rails项目中的config/application.rb 文件中的config 注意这个方法是个类方法，这样我们在我们的项目的config/application.rb文件中才可以使用config直接调用</p>

<pre><code>@config ||= Application::Configuration.new(find_root_with_flag("config.ru", Dir.pwd))  #这个配置在rails/application/configuration.rb文件
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>这个Application 类继承了 Engine，这就是说，我们的rails application 也是一个engine。当一个类继承了这个类的时候，base.instance 将会赋值到Rails.application ,这个base.instance将会创建一个我们项目的实例。这就是说，我们可以在我们的项目的任何一个地方使用Rails.application来访问我们的项目的实例。我们看看Engine.rb文件:</p>

<p>``` ruby rails/engine.rb</p>

<p>class Engine &lt; Railtie  #继承自 Railtie 类
  autoload :Configuration, &ldquo;rails/engine/configuration&rdquo; #加载 enging/configuration.rb这个文件</p>

<p>def inherited(base)
  unless base.abstract_railtie?</p>

<pre><code>Rails::Railtie::Configuration.eager_load_namespaces &lt;&lt; base

base.called_from = begin
  call_stack = if Kernel.respond_to?(:caller_locations)
    caller_locations.map(&amp;:path)
  else
    # Remove the line number from backtraces making sure we don't leave anything behind
    caller.map { |p| p.sub(/:\d+.*/, '') }
  end

  File.dirname(call_stack.detect { |p| p !~ %r[railties[\w.-]*/lib/rails|rack[\w.-]*/lib/rack] })
end
</code></pre>

<p>  end</p>

<p>  super  #调用Railtie这个类的inherited
end</p>

<p>def instance  #这个instance方法就是我们在application.rb 文件中 base.instance的出处
  @instance ||= new
end</p>

<p>end</p>

<p>```</p>

<p>这个Engine类继承了Railtie类，Railtie几乎遍布所有的ruby gems ，任何想要集成到rails项目的gems都应该有它自己的railtie。我们看看Railtie:</p>

<p>``` ruby  rails/railtie.rb</p>

<p>class Railtie
  autoload :Configuration, &ldquo;rails/railtie/configuration&rdquo;
  class &lt;&lt; self</p>

<pre><code>def inherited(base)
  unless base.abstract_railtie?
    subclasses &lt;&lt; base
  end
end
</code></pre>

<p>  end</p>

<p>```</p>

<p>这个类没有继承其他的类，但是他include了一个confirugration.rb 文件，无论这个Railtie类什么时候被继承，这个文件都会被加载。 我们再来看看关于网站配置的文件,在rails/application.rb文件中，include了  lib/rails/application/configuration.rb 文件:</p>

<p>``` ruby appalication/configuration.rb</p>

<p>module Rails
  class Application</p>

<pre><code>class Configuration &lt; ::Rails::Engine::Configuration
  def initialize(*)
    super
    self.encoding = "utf-8"
    @allow_concurrency             = nil
    @consider_all_requests_local   = false
    @filter_parameters             = []
    @filter_redirect               = []
    @helpers_paths                 = []
    @serve_static_assets           = true
    @static_cache_control          = nil
    @force_ssl                     = false
    @ssl_options                   = {}
    @session_store                 = :cookie_store
    @session_options               = {}
    @time_zone                     = "UTC"
    @beginning_of_week             = :monday
    @log_level                     = nil
    @middleware                    = app_middleware
    @generators                    = app_generators
    @cache_store                   = [ :file_store, "#{root}/tmp/cache/" ]
    @railties_order                = [:all]
    @relative_url_root             = ENV["RAILS_RELATIVE_URL_ROOT"]
    @reload_classes_only_on_change = true
    @file_watcher                  = ActiveSupport::FileUpdateChecker
    @exceptions_app                = nil
    @autoflush_log                 = true
    @log_formatter                 = ActiveSupport::Logger::SimpleFormatter.new
    @eager_load                    = nil
    @secret_token                  = nil
    @secret_key_base               = nil

    @assets = ActiveSupport::OrderedOptions.new
    @assets.enabled                  = true
    @assets.paths                    = []
    @assets.precompile               = [ Proc.new { |path, fn| fn =~ /app\/assets/ &amp;&amp; !%w(.js .css).include?(File.extname(path)) },
                                         /(?:\/|\\|\A)application\.(css|js)$/ ]
    @assets.prefix                   = "/assets"
    @assets.version                  = '1.0'
    @assets.debug                    = false
    @assets.compile                  = true
    @assets.digest                   = false
    @assets.cache_store              = [ :file_store, "#{root}/tmp/cache/assets/#{Rails.env}/" ]
    @assets.js_compressor            = nil
    @assets.css_compressor           = nil
    @assets.logger                   = nil
  end
end
</code></pre>

<p>  end
end</p>

<p>```
这个Configurationl类在初始化的时候定义了很多的实例变量，这些变量大部分我们在做我们项目的配置的时候都见过。并且，这个类继承了::Rails::Engine::Configuration，我们再看看这个类:</p>

<p>``` ruby  engine/configuration.rb</p>

<p>module Rails
  class Engine</p>

<pre><code>class Configuration &lt; ::Rails::Railtie::Configuration
  attr_reader :root
  attr_writer :middleware, :eager_load_paths, :autoload_once_paths, :autoload_paths

  def initialize(root=nil)
    super()
    @root = root
    @generators = app_generators.dup
  end
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>这个类继承了railtie 下的configuration类:</p>

<p>``` ruby railtie/configuration.rb</p>

<p>module Rails
  class Railtie</p>

<pre><code>class Configuration
  def initialize
    @@options ||= {}
  end
end
</code></pre>

<p>  end
ene</p>

<p>```</p>

<p>看过了上面的代码之后，我们再看最后一个文件，这个文件就是在config/environment.rb 文件中的最后一行的方法:</p>

<p>``` ruby  config/environment.rb</p>

<h1>Load the rails application</h1>

<p>require File.expand_path(&lsquo;../application&rsquo;, <strong>FILE</strong>)</p>

<h1>Initialize the rails application</h1>

<p>QuillExpress::Application.initialize!</p>

<p>```</p>

<p>看一下最后一行，这一行就是我们项目的初始化过程，这个过程的实现在lib/rails/application.rb文件:</p>

<p>``` ruby rails/application.rb</p>

<p>def initialize!(group=:default) #:nodoc:
  raise &ldquo;Application has been already initialized.&rdquo; if @initialized
  run_initializers(group, self) #执行初始化
  @initialized = true
  self
end</p>

<p>```</p>

<p>接下来看看run_initializers方法在哪</p>

<p>``` ruby  initializable.rb</p>

<p>  def run_initializers(group=:default, *args)</p>

<pre><code>return if instance_variable_defined?(:@ran)
initializers.tsort_each do |initializer|
  initializer.run(*args) if initializer.belongs_to?(group)
end
@ran = true
</code></pre>

<p>  end</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Active_support_lazy_load_hooks]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/active-support-lazy-load-hooks/"/>
    <updated>2014-02-25T08:42:32+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/active-support-lazy-load-hooks</id>
    <content type="html"><![CDATA[<p>在rails的源码中经常看到有ActiveSupport.on_load这样的代码出现，于是找到代码的定义处(active_support/lazy_load_hooks.rb)中，里面的代码很简单，但是为我们提供的功能却很强大，下面我们来看一下:</p>

<p>``` ruby</p>

<p>@load_hooks = Hash.new { |h,k| h[k] = [] } #定义一个空的hash,用来存放还没有被执行的blocks
@loaded = Hash.new { |h,k| h[k] = [] } #定义一个空hash,这个空hash主要用来存放已经被加载的载体类。</p>

<p>def self.on_load(name, options = {}, &amp;block)#这个方法是见到最多的，很多我们需要将来执行的代码块儿都是通过这个方法存储的
  @loaded[name].each do |base|</p>

<pre><code>execute_hook(base, options, block)
</code></pre>

<p>  end</p>

<p>  @load_hooks[name] &lt;&lt; [block, options] #每次调用该方法时，该方法后面block要执行的动作都被暂时保存在这个变量中
end</p>

<p>def self.execute_hook(base, options, block) #这个方法主要是用来执行存储的代码用
  if options[:yield]</p>

<pre><code>block.call(base)
</code></pre>

<p>  else</p>

<pre><code>base.instance_eval(&amp;block)
</code></pre>

<p>  end
end</p>

<p>def self.run_load_hooks(name, base = Object) #执行开始的地方，当某个文件require了这个module之后，并切调用了这个方法之后，执行开始
  @loaded[name] &lt;&lt; base
  @load_hooks[name].each do |hook, options|</p>

<pre><code>execute_hook(base, options, hook)
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>下面来看一下这个azy_load_hooks用在什么地方，我们打开active_record/railtie.rb这个文件，我们会看见很多类似的代码:</p>

<!-- more -->


<p>``` ruby</p>

<p>ActiveSupport.on_load(:active_record) do
  filename = File.join(app.config.paths[&ldquo;db&rdquo;].first, &ldquo;schema_cache.dump&rdquo;)</p>

<p>  if File.file?(filename)</p>

<pre><code>cache = Marshal.load File.binread filename
if cache.version == ActiveRecord::Migrator.current_version
  self.connection.schema_cache = cache
else
  warn "Ignoring db/schema_cache.dump because it has expired. The current schema version is #{ActiveRecord::Migrator.current_version}, but the one in the cache is #{cache.version}."
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>方法后的block是我们真正要做的额外的操作这些操作可能会延长我们的app的启动的过程，所以，我们在这里使用on_load将这些要执行的方法暂时存放在一个变量里，只有在程序需要的时候才去执行这些额外的操作，这样的话，我们的app启动的就会更快</p>

<p>最后的执行是在active_record/base.rb文件中，代码的最下面执行到了run_load_hooks方法:</p>

<p>``` ruby</p>

<p>ActiveSupport.run_load_hooks(:active_record, Base) #调用run_load_hooks，额外的操作开始执行。</p>

<p>```</p>

<p>如果你打开rails其他的railtie的话，你会发现也有azy_load_blocks方法，他们起到的作用都是一样的，即，提高我们应用启动的速度</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Active_support_autoload]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/25/active-support-autoload/"/>
    <updated>2014-02-25T05:43:38+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/25/active-support-autoload</id>
    <content type="html"><![CDATA[<p>在看rails源码的时候发现很多地方用到了autoload，意识到这个autoload是整个框架的基础方法，于是有时间看了遍里面的代码，关键的方法都定义在autoload.rb(active_support/dependencies/autoload.rb)下面我们来看下这个文件里面都做了些什么事:</p>

<p>``` ruby</p>

<p>def self.extended(base)
  base.class_eval do</p>

<pre><code>@_autoloads = {} #hash 盛放该module需要一次性require的文件,每个元素的key为大写的module的名字，value为该module对应的文件(包含路径)
@_under_path = nil #字符串，代表需要load的某个模块的路径
@_at_path = nil    #字符串，代表需要load的某个模块的路径
@_eager_autoload = false #标识位
</code></pre>

<p>  end
end</p>

<p>```</p>

<p>以上代码，很明显，给base(某个可能extend ActiveSupport::Autoload的模块)声明了几个实例变量。</p>

<!--more-->


<p>再来看看autoload方法,这个方法是我们在rails源码中看到最多的
``` ruby</p>

<p>def autoload(const_name, path = @_at_path)
  unless path</p>

<pre><code>full = [name, @_under_path, const_name.to_s].compact.join("::")#生成一个用::隔开的字符串
path = Inflector.underscore(full)#生成要加载模块的路径 例如:ActiveSupport #=&gt; active_support
</code></pre>

<p>  end</p>

<p>  if @_eager_autoload</p>

<pre><code>@_autoloads[const_name] = path
</code></pre>

<p>  end</p>

<p>  super const_name, path #调用ruby的autoload方法，这个方法是一个懒加载，即只有用到模块中的方法或者变量的时候，才会去require该文件
end</p>

<p>```</p>

<p>接下来的几个方法:</p>

<p>``` ruby
def autoload_under(path)
  @<em>under_path, old_path = path, @</em>under_path #设置了@<em>under_path变量
  yield
ensure
  @</em>under_path = old_path
end</p>

<p>def autoload_at(path)
  @<em>at_path, old_path = path, @</em>at_path#设置了@<em>at_path变量
  yield
ensure
  @</em>at_path = old_path
end</p>

<p>def eager_autoload #这个方法用来一次性require所有所需的文件
  old_eager, @<em>eager_autoload = @</em>eager_autoload, true#设置了@<em>eager_autoload变量为true
  yield
ensure
  @</em>eager_autoload = old_eager
end
```</p>

<p>以上这三个方法都是后面跟着block的，所以这三个函数都yield了这个block，并且设置了base模块的几个基本的实例变量，这些block中的内容，如果你才看看rails源码的话，你会发现，基本上都是在里面调用了autoload方法:</p>

<p>``` ruby
autoload_under &ldquo;renderer&rdquo; do
  autoload :Renderer
  autoload :AbstractRenderer
  autoload :PartialRenderer
  autoload :TemplateRenderer
  autoload :StreamingTemplateRenderer
end</p>

<p>autoload_at &ldquo;action_view/template/resolver&rdquo; do
  autoload :Resolver
  autoload :PathResolver
  autoload :OptimizedFileSystemResolver
  autoload :FallbackFileSystemResolver
end</p>

<p>eager_autoload do
  autoload :Base
  autoload :Context
  autoload :CompiledTemplates, &ldquo;action_view/context&rdquo;
  autoload :Digestor
  autoload :Helpers
  autoload :LookupContext
  autoload :Layouts
  autoload :PathSet
  autoload :RecordIdentifier
  autoload :Rendering
  autoload :RoutingUrlFor
  autoload :Template
  autoload :ViewPaths
end</p>

<p>```</p>

<p>这个时候我们回过头来在来看 autoload方法，里面有这么一句:</p>

<p>``` ruby</p>

<p>if @<em>eager_autoload
  @</em>autoloads[const_name] = path
end</p>

<p>```
也就是说，只要我们调用了eager_autoload这个方法，我们就会设置@<em>eager_autoload值为true，并且我们还设置了@</em>autoloads这个hash，这个hash就是用来盛放我们将来需要一次性require的文件的路径</p>

<p>再来看看最重要的一个方法:</p>

<p>``` ruby</p>

<p>def eager_load!
  @_autoloads.values.each { |file| require file }
end</p>

<p>```</p>

<p>这个方法是我们最终实现饥饿加载的最终代码所在，即一次性require我们所需的所有的module文件。</p>

<p>这个autoload模块就是用来方便我们require我们所需要的module文件的,如果一个module extend了这个autoload模块的话，那么他就可以利用autoload这个方法来加载同一个module 名命名的文件加下的其他模块文件而不用制定文件的路径。还可以通过eager_autoload方法来指定这个module需要批量require 的module的名字，然后通过 eager_load!方法就可以实现一次性require多个文件，这个方法的好处是避免了我们在文件的开头写很多的require，如下面的例子所示:</p>

<p>``` ruby</p>

<p>module MyLib
  extend ActiveSupport::Autoload</p>

<p>  autoload :Model</p>

<p>  eager_autoload do</p>

<pre><code>autoload :Cache
</code></pre>

<p>  end
end</p>

<p>Then your library can be eager loaded by simply calling:</p>

<p>MyLib.eager_load!</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveSupport::Concern Source Code Analyse]]></title>
    <link href="http://gaoguoxin.github.io/blog/2014/02/21/hello-world/"/>
    <updated>2014-02-21T02:44:45+00:00</updated>
    <id>http://gaoguoxin.github.io/blog/2014/02/21/hello-world</id>
    <content type="html"><![CDATA[<p>1、首先我们来看个例子
``` ruby
module M
  def self.included(base)</p>

<pre><code>base.extend ClassMethods
base.send(:include, InstanceMethods)
scope :disabled, where(:disabled =&gt; true)
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end</p>

<p>  module InstanceMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```
这是一个再普通不过的module了，当某个模块(或者类)include它以后，它让目标模块(或者类)去txtend  ClassMethods 这个模块，并去include  InstanceMethods 这个模块，这样的话，目标模块(或者类)在include M 的时候，这个目标模块(或者类)就拥有了ClassMethods这个模块中定义的方法并把这些方法当作类方法，并拥有了InstanceMethods模块的方法，并把这个模块中的方法作为自己的实例方法。如果你不觉得麻烦的话，那么这种方式是可选的或者，干脆直接定义实例方法，而不定义InstanceMethods，因为在include一个module的时候，module里面定义的方法自动就为实例方法。</p>

<!-- more -->


<p>2、再来看看另外一个例子
``` ruby
module Foo
  def self.included(base)</p>

<pre><code>base.class_eval do
  def self.method_injected_by_foo
    #...对宿主做某些操作，例如增強功能等等
  end
end
</code></pre>

<p>  end
end</p>

<p>module Bar
  def self.included(base)</p>

<pre><code>base.method_injected_by_foo #这里调用了Foo这个module定义的method_injected_by_foo方法
</code></pre>

<p>  end
end</p>

<p>class Host
  include Foo
  include Bar
  #要想让让Bar被include的时候执行Foo这个module中定义的method_injected_by_foo方法，必须在include  Bar之前先要解决依赖关系，即 include Foo
end
```
上面这个例子对于大多数的使用者来说，就会很麻烦，因为我在include某个模块的时候必须解决他们的依赖关系，要知道我include的模块依赖哪些其他模块，这个对使用者来说有点困难。为了解决这个依赖的问题，貌似我们可以这样做，即将依赖关系放到module内去解决,如下:</p>

<p>```ruby
 module Foo
   def self.included(base)</p>

<pre><code> base.class_eval do
   def self.method_injected_by_foo
     #...对宿主做某些操作，例如增強功能等等
   end
 end
</code></pre>

<p>   end
 end</p>

<p> module Bar
   include Foo #在这里解决依赖问题</p>

<p>   def self.included(base)</p>

<pre><code> base.send(:do_host_something)
</code></pre>

<p>   end</p>

<p> end</p>

<p> class Host
   include Bar # 这里只需要include一个Bar，而不用关心依赖问题
 end
```
以上代码看似可以执行，但是问题是，在Foo被 Bar include的时候，对于Foo来说，此时的base为Bar，而不是 class Host，所以我们没法在Host include的时候，拿到Host中的do_host_something方法，因为它根本就不在Host中</p>

<p>3、为了解决以上讨论的两个问题，ActiveSupport::Concern出现了，对于上面的问题，你只要这样操作就可以了:</p>

<p>对于第一个问题，你可以这样解决:
``` ruby
require &lsquo;active_support/concern&rsquo;
module M
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>scope :disabled, -&gt; { where(disabled: true) }
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```</p>

<p>对于第二个问题，你可以这样解决:
``` ruby</p>

<pre><code>require 'active_support/concern'
module Foo
  extend ActiveSupport::Concern
  included do
    def self.method_injected_by_foo
      ...
    end
  end
end

module Bar
  extend ActiveSupport::Concern
  include Foo

  included do
    self.method_injected_by_foo
  end
end

class Host
  include Bar # 只include Bar就可以了，其他的我们不用关心
end
</code></pre>

<p>```</p>

<p>4、接下来，我们看看 active_support/concern 的源码是怎样来实现这些逻辑的</p>

<p>a、首先定义了一个异常类:
``` ruby
class MultipleIncludedBlocks &lt; StandardError
  def initialize</p>

<pre><code>super "Cannot define multiple 'included' blocks for a Concern"
</code></pre>

<p>  end
end
<code>
b、模块被extend的时候，为base添加一个类实例变量，并赋值为空数组，这个类实例变量是用来记录base模块(或者类)的所有依赖模块的
</code> ruby
def self.extended(base)
  base.instance_variable_set(:@_dependencies, [])
end
```
c、重写了ruby的 append_features 方法，这个append_features 是ruby Module中的方法，愿意是当一个module(a)被include 到另一个module(b)的时候，就会调用module  a 中的这个append_features方法，并且把module b 做为参数传给append_features方法，然后将module a中的常量，方法，变量添加到module b 中。</p>

<p>``` ruby
def append_features(base) #此时的base代表module b
  if base.instance_variable_defined?(:@_dependencies)</p>

<pre><code>base.instance_variable_get(:@_dependencies) &lt;&lt; self  #此时的self是module a 
return false
</code></pre>

<p>  else</p>

<pre><code>return false if base &lt; self 
@_dependencies.each { |dep| base.send(:include, dep) }  # module b 去 循环include  modulea 的依赖 module
super  # 这个super 调用的是ruby原来的 append_features 方法
base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods) #module b 去extend  module a 中定一的 ClassMethods 模块
base.class_eval(&amp;@_included_block) if instance_variable_defined?(:@_included_block)  # 为module b 动态添加一些内容(block中的内容)
</code></pre>

<p>  end
end
```</p>

<p>来看一下这个方法的具体逻辑，首先判断 module b 中是否已经有了类实例变量@<em>dependencies，如果有的话，那么将被include的module a 追加到这个变量中，如果一个module 中设置了 @</em>dependencies 这个变量 那么说明 该module 肯定extend 了active_support/concern，如果一个module中没有设置这个变量，可以肯定，该module 没有 extend  active_support/concern ，则该module是最后应用的那个module 。</p>

<p>d、重新定义included 方法，included方法是ruby module中的方法，当一个module a 被另一个module b include的时候，module a 的included 方法就会执行，并把module 作为一个参数 base 传递给该方法，我们可以在这里对base做一些inject，这里对included方法进行了重写。</p>

<p>``` ruby
def included(base = nil, &amp;block)
  if base.nil?</p>

<pre><code>raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)
@_included_block = block
</code></pre>

<p>  else</p>

<pre><code>super
</code></pre>

<p>  end
end
```</p>

<p>当module a 被module include 后，如果这个方法传递了一个base，那么就直接使用ruby module中的included方法，如果我们在include的时候，传递的是一个block，那么就将该block 转化为proc对象，并赋值给 @_included_block 变量，这个变量会在 上边的 append_features方法中使用，这个block一般是用来动态给base 添加一些方法活属性用。例如:</p>

<p>``` ruby
require &lsquo;active_support/concern&rsquo;
module M
  extend ActiveSupport::Concern</p>

<p>  included do  #这里调用included方法，我们只传递了一个block，并且这个block中用来声明一些方法，将来这些方法会成为base的类方法</p>

<pre><code>scope :disabled, -&gt; { where(disabled: true) }
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>#...
</code></pre>

<p>  end
end
```</p>
]]></content>
  </entry>
  
</feed>
