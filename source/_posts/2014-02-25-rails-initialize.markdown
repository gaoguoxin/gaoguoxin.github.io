---
layout: post
title: "rails_initialize"
date: 2014-02-25 09:26:57 +0000
comments: true
categories: Rails
---

我们经常在我们的rails项目的根目录执行这样的操作，比如:

``` ruby 

rails s  #=> 启动本地服务器，让我们的项目跑起来
rails c  #=> 启动console
rails db #=> 启动我们的database终端

```

上面的命令你可能已经再熟悉不过了，但是你想过没有，为什么rails命令可以执行?难道rails是我们系统的命令么?这就设计我本文要讲的，rails的启动流成了。在你的终端输入

``` bash

which rails #=> /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin/rails (这个路径是你的rails可执行文件的所在路径)

echo $PATH  #=> /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin (我们的系统环境变量)

```

<!-- more -->

以上输出说明，我们的rails命令是一个可执行脚本文件，并且这个脚本文件被我们添加到了系统的环境变量。下面我们来看看这个脚本的具体内容:

``` ruby  /home/naitnix/.rvm/gems/ruby-1.9.3-p194/bin/rails
#!/usr/bin/env ruby  这句话的意思是使用系统环境变量中的ruby解释器，与shell中的  #!/usr/bin/bash不同
#
# This file was generated by RubyGems.
#
# The application 'railties' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'  #加载rubygems

version = ">= 0"

if ARGV.first =~ /^_(.*)_$/ and Gem::Version.correct? $1 then
  version = $1
  ARGV.shift
end

gem 'railties', version #导入railties这个gem，这是rails中的核心概念
load Gem.bin_path('railties', 'rails', version)  #加载railties目录下的rails

```

如果我们在我们项目的根目录输入 bundle show rails 看一下我们的rails装在了哪里，他会告诉我们类似下面这样的一个路径:

``` ruby

/home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/rails-3.2.16

```

如果我们进入这个目录查看里面的内容，你会发现里面是空的，这是怎么回事?

``` ruby 

cd /home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/rails-3.2.16

ls # => 空的，没有任何内容

```

自rails3起，rails的所有的源代码都放到了railties 里面，如果我们回到 上面一个目录，你会发现有一个对应的 railties-3.2.16目录:

``` ruby 

cd ../

ls #=> railties-3.2.16

cd railties-3.2.16

ls -l 

drwxrwxr-x 2 naitnix naitnix 4096 Feb  8 08:56 bin
-rw-r--r-- 1 naitnix naitnix 4966 Dec  9 05:44 CHANGELOG.md
drwxrwxr-x 6 naitnix naitnix 4096 Dec  9 05:44 guides
drwxrwxr-x 3 naitnix naitnix 4096 Dec  9 05:44 lib
-rw-r--r-- 1 naitnix naitnix  765 Dec  9 05:44 README.rdoc


```

如果你从github  clone了rails的源码的话，你会发现他的代码结构与我们上面的目录类似，只是多了几个rails的组件:

``` ruby

drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionmailer
drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionpack
drwxrwxr-x 4 naitnix naitnix 4096 Feb 20 09:10 actionview
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activemodel
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activerecord
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 activesupport
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 ci
-rw-rw-r-- 1 naitnix naitnix 1203 Feb 20 09:10 CONTRIBUTING.md
-rw-rw-r-- 1 naitnix naitnix 2203 Feb 20 09:10 Gemfile
drwxrwxr-x 7 naitnix naitnix 4096 Feb 20 09:10 guides
-rw-rw-r-- 1 naitnix naitnix  524 Feb 20 09:10 install.rb
-rw-rw-r-- 1 naitnix naitnix   51 Feb 20 09:10 load_paths.rb
-rw-rw-r-- 1 naitnix naitnix 1159 Feb 20 09:10 rails.gemspec
-rw-rw-r-- 1 naitnix naitnix   10 Feb 20 09:10 RAILS_VERSION
drwxrwxr-x 5 naitnix naitnix 4096 Feb 20 09:10 railties
-rw-rw-r-- 1 naitnix naitnix 2844 Feb 20 09:10 Rakefile
-rw-rw-r-- 1 naitnix naitnix 4029 Feb 20 09:10 README.md
-rw-rw-r-- 1 naitnix naitnix 7671 Feb 20 09:10 RELEASING_RAILS.rdoc
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 tasks
drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 tools
-rw-rw-r-- 1 naitnix naitnix  158 Feb 20 09:10 version.rb


```

你会看到上面的列表中有个railties目录，这个目录就是我们上面说的rails启动流程的源码目录，让我们进入这个目录看看:

``` ruby

drwxrwxr-x 2 naitnix naitnix 4096 Feb 20 09:10 bin
-rw-rw-r-- 1 naitnix naitnix 8898 Feb 20 09:10 CHANGELOG.md
drwxrwxr-x 3 naitnix naitnix 4096 Feb 20 09:10 lib
-rw-rw-r-- 1 naitnix naitnix 1072 Feb 20 09:10 MIT-LICENSE
-rw-rw-r-- 1 naitnix naitnix 1028 Feb 20 09:10 railties.gemspec
-rw-rw-r-- 1 naitnix naitnix 1296 Feb 20 09:10 Rakefile
-rw-rw-r-- 1 naitnix naitnix 3382 Feb 20 09:10 RDOC_MAIN.rdoc
-rw-rw-r-- 1 naitnix naitnix  803 Feb 20 09:10 README.rdoc
drwxrwxr-x 9 naitnix naitnix 4096 Feb 20 09:10 test


```


里面有两个目录我们需要关心，一个是bin，另一个是lib，我们在这篇文章开始说的，rails可执行文件要加载一个railties目录下的rails可执行文件，这个rails可执行文件就在这个bin目录。lib目录，里面有个rails目录，这个目录里的代码才使我们真正的启动相关的代码所在:

``` ruby

-rw-rw-r-- 1 naitnix naitnix   211 Feb 20 09:10 all.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 api
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 application
-rw-rw-r-- 1 naitnix naitnix   463 Feb 20 09:10 application_controller.rb
-rw-rw-r-- 1 naitnix naitnix 14732 Feb 20 09:10 application.rb
-rw-rw-r-- 1 naitnix naitnix  1950 Feb 20 09:10 app_rails_loader.rb
-rw-rw-r-- 1 naitnix naitnix   857 Feb 20 09:10 backtrace_cleaner.rb
-rw-rw-r-- 1 naitnix naitnix   381 Feb 20 09:10 cli.rb
-rw-rw-r-- 1 naitnix naitnix  2087 Feb 20 09:10 code_statistics_calculator.rb
-rw-rw-r-- 1 naitnix naitnix  2836 Feb 20 09:10 code_statistics.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 commands
-rw-rw-r-- 1 naitnix naitnix   328 Feb 20 09:10 commands.rb
-rw-rw-r-- 1 naitnix naitnix  3619 Feb 20 09:10 configuration.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 console
-rw-rw-r-- 1 naitnix naitnix   500 Feb 20 09:10 deprecation.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 engine
-rw-rw-r-- 1 naitnix naitnix 24556 Feb 20 09:10 engine.rb
drwxrwxr-x 9 naitnix naitnix  4096 Feb 20 09:10 generators
-rw-rw-r-- 1 naitnix naitnix  9853 Feb 20 09:10 generators.rb
-rw-rw-r-- 1 naitnix naitnix   588 Feb 20 09:10 info_controller.rb
-rw-rw-r-- 1 naitnix naitnix  3129 Feb 20 09:10 info.rb
-rw-rw-r-- 1 naitnix naitnix  2276 Feb 20 09:10 initializable.rb
-rw-rw-r-- 1 naitnix naitnix  2175 Feb 20 09:10 mailers_controller.rb
-rw-rw-r-- 1 naitnix naitnix  5664 Feb 20 09:10 paths.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 rack
-rw-rw-r-- 1 naitnix naitnix   190 Feb 20 09:10 rack.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 railtie
-rw-rw-r-- 1 naitnix naitnix  7467 Feb 20 09:10 railtie.rb
-rw-rw-r-- 1 naitnix naitnix   985 Feb 20 09:10 rubyprof_ext.rb
-rw-rw-r-- 1 naitnix naitnix   302 Feb 20 09:10 ruby_version_check.rb
-rw-rw-r-- 1 naitnix naitnix  4456 Feb 20 09:10 source_annotation_extractor.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 tasks
-rw-rw-r-- 1 naitnix naitnix   188 Feb 20 09:10 tasks.rb
drwxrwxr-x 4 naitnix naitnix  4096 Feb 20 09:10 templates
-rw-rw-r-- 1 naitnix naitnix  1218 Feb 20 09:10 test_help.rb
drwxrwxr-x 2 naitnix naitnix  4096 Feb 20 09:10 test_unit
-rw-rw-r-- 1 naitnix naitnix   158 Feb 20 09:10 version.rb
-rw-rw-r-- 1 naitnix naitnix   150 Feb 20 09:10 welcome_controller.rb

```

如果我们看见一些以Rails开头的路径，多半指的是这个rails目录。

好，介绍完了rails的源码目录结构，我们接着我们开头的部分讲，当我们在终端输入rails 命令后，系统会到环境变量的目录中查找到rails可执行文件，并利用环境变量中的ruby解释器去解释这个文件，那么我们在前面看到了，这个文件主要做了两件是:第一时间在rubygems,第二就是 load了rails源码目录(bin/rails)中的rails命令文件，那么我们来看看这个rails可执行文件中到底做了哪些事:

``` ruby railties/bin/rails

#!/usr/bin/env ruby

if File.exists?(File.join(File.expand_path('../../..', __FILE__), '.git'))
  railties_path = File.expand_path('../../lib', __FILE__)
  $:.unshift(railties_path)
end
require "rails/cli"

```

这个文件主要是require了 /home/naitnix/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.16/lib/rails/cli.rb这个文件，所以，让我们来看看这个cli.rb文件到底做了写什么

``` ruby lib/rails/cli.rb

require 'rails/app_rails_loader'

# If we are inside a Rails application this method performs an exec and thus
# the rest of this script is not run.
Rails::AppRailsLoader.exec_app_rails

require 'rails/ruby_version_check'
Signal.trap("INT") { puts; exit(1) }

if ARGV.first == 'plugin'
  ARGV.shift
  require 'rails/commands/plugin'
else
  require 'rails/commands/application'
end

```

这个文件主要做了这么几件事:

-  require 了 rails 目录下的app_rails_loader文件
-  执行exec_app_rails方法
-  做ruby版本的检查
-  判断rails命令后面的参数，如果跟的是plugin那么require rails/commands/plugin这个文件，否则的话，require rails/commands/application

接下来，我们看看这个app_rails_loader文件中的exec_app_rails方法:

``` ruby app_rails_loader.rb

RUBY = Gem.ruby  #定义常量
EXECUTABLES = ['bin/rails', 'script/rails']#rails可执行文件的目录

def self.exec_app_rails
  original_cwd = Dir.pwd

  loop do
    if exe = find_executable
      contents = File.read(exe)  #contents为bin/rails或者script/rails

      if contents =~ /(APP|ENGINE)_PATH/#如果contents为script/rails，则表示我们当前执行rails命令的目录是我们项目的根目录
        exec RUBY, exe, *ARGV执行script/rails命令
        break # non reachable, hack to be able to stub exec in the test suite
      elsif exe.end_with?('bin/rails') && contents.include?('This file was generated by Bundler')
        #rails4 里面，移除了script目录，添加了bin目录，并将rails，bundle，rake等命令放到了这个bin目录
        $stderr.puts(BUNDLER_WARNING)
        Object.const_set(:APP_PATH, File.expand_path('config/application', Dir.pwd))#设置常量 APP_PATH
        require File.expand_path('../boot', APP_PATH) #require  boot.rb
        require 'rails/commands' # require lib/rails/commands.rb文件
        break
      end
    end

    # If we exhaust the search there is no executable, this could be a
    # call to generate a new application, so restore the original cwd.
    Dir.chdir(original_cwd) and return if Pathname.new(Dir.pwd).root?

    # Otherwise keep moving upwards in search of an executable.
    Dir.chdir('..')
  end
end

def self.find_executable
  EXECUTABLES.find { |exe| File.file?(exe) }
end

```

那么来看看这个script/rails(或者bin/rails)文件里都做了哪些事:

``` ruby script/rails(bin/rails)

APP_PATH = File.expand_path('../../config/application',  __FILE__)#设置常量 APP_PATH
require File.expand_path('../../config/boot',  __FILE__)#require  boot.rb
require 'rails/commands'# require lib/rails/commands.rb文件

```

看看项目目录中的config/boot.rb文件的内容:

``` ruby config/boot.rb

# Set up gems listed in the Gemfile.
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])

```

这个文件的内容很简单，load  Gemfile文件并run bundler。接下来我们看一下 railties/lib/rails/commands.rb文件:

``` ruby railties/lib/rails/commands.rb

ARGV << '--help' if ARGV.empty?

aliases = {  #设置了几个常用的命令别名
  "g"  => "generate",
  "d"  => "destroy",
  "c"  => "console",
  "s"  => "server",
  "db" => "dbconsole",
  "r"  => "runner"
}

command = ARGV.shift
command = aliases[command] || command

require 'rails/commands/commands_tasks'  

Rails::CommandsTasks.new(ARGV).run_command!(command) #执行命令方法


``` 

上面的执行命令的方法在rails/commands/commands_tasks.rb文件，我们来看看:

``` ruby rails/commands/commands_tasks.rb

module Rails
  # This is a class which takes in a rails command and initiates the appropriate
  # initiation sequence.
  #
  # Warning: This class mutates ARGV because some commands require manipulating
  # it before they are run.
  class CommandsTasks # :nodoc:
    attr_reader :argv

    HELP_MESSAGE = <<-EOT
Usage: rails COMMAND [ARGS]

The most common rails commands are:
 generate    Generate new code (short-cut alias: "g")
 console     Start the Rails console (short-cut alias: "c")
 server      Start the Rails server (short-cut alias: "s")
 dbconsole   Start a console for the database specified in config/database.yml
             (short-cut alias: "db")
 new         Create a new Rails application. "rails new my_app" creates a
             new application called MyApp in "./my_app"

In addition to those, there are:
 application  Generate the Rails application code
 destroy      Undo code generated with "generate" (short-cut alias: "d")
 plugin new   Generates skeleton for developing a Rails plugin
 runner       Run a piece of code in the application environment (short-cut alias: "r")

All commands can be run with -h (or --help) for more information.
EOT

    COMMAND_WHITELIST = %(plugin generate destroy console server dbconsole application runner new version help)

    def initialize(argv)
      @argv = argv
    end

    def run_command!(command)
      command = parse_command(command)
      if COMMAND_WHITELIST.include?(command)
        send(command)
      else
        write_error_message(command)
      end
    end

    def plugin
      require_command!("plugin")
    end

    def generate
      generate_or_destroy(:generate)
    end

    def destroy
      generate_or_destroy(:destroy)
    end

    def console
      require_command!("console")
      options = Rails::Console.parse_arguments(argv)

      # RAILS_ENV needs to be set before config/application is required
      ENV['RAILS_ENV'] = options[:environment] if options[:environment]

      # shift ARGV so IRB doesn't freak
      shift_argv!

      require_application_and_environment!
      Rails::Console.start(Rails.application, options)
    end

    def server
      set_application_directory!
      require_command!("server")

      Rails::Server.new.tap do |server|
        # We need to require application after the server sets environment,
        # otherwise the --environment option given to the server won't propagate.
        require APP_PATH
        Dir.chdir(Rails.application.root)
        server.start
      end
    end

    def dbconsole
      require_command!("dbconsole")
      Rails::DBConsole.start
    end

    def application
      require_command!("application")
    end

    def runner
      require_command!("runner")
    end

    def new
      if %w(-h --help).include?(argv.first)
        require_command!("application")
      else
        exit_with_initialization_warning!
      end
    end

    def version
      argv.unshift '--version'
      require_command!("application")
    end

    def help
      write_help_message
    end

    private

      def exit_with_initialization_warning!
        puts "Can't initialize a new Rails application within the directory of another, please change to a non-Rails directory first.\n"
        puts "Type 'rails' for help."
        exit(1)
      end

      def shift_argv!
        argv.shift if argv.first && argv.first[0] != '-'
      end

      def require_command!(command)
        require "rails/commands/#{command}"
      end

      def generate_or_destroy(command)
        require 'rails/generators'
        require_application_and_environment!
        Rails.application.load_generators
        require "rails/commands/#{command}"
      end

      # Change to the application's path if there is no config.ru file in current directory.
      # This allows us to run `rails server` from other directories, but still get
      # the main config.ru and properly set the tmp directory.
      def set_application_directory!
        Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exist?(File.expand_path("config.ru"))
      end

      def require_application_and_environment!
        require APP_PATH
        Rails.application.require_environment!
      end

      def write_help_message
        puts HELP_MESSAGE
      end

      def write_error_message(command)
        puts "Error: Command '#{command}' not recognized"
        if %x{rake #{command} --dry-run 2>&1 } && $?.success?
          puts "Did you mean: `$ rake #{command}` ?\n\n"
        end
        write_help_message
        exit(1)
      end

      def parse_command(command)
        case command
        when '--version', '-v'
          'version'
        when '--help', '-h'
          'help'
        else
          command
        end
      end
  end
end

```
看一下server这个方法，首先跳转到项目根目录，紧接着require commonds/server.rb这个文件，接着，new了一个Rails::Server的实例并启动这个server，接下来我们看看server.rb的内容：

``` ruby  server.rb

class Server < ::Rack::Server  #继承了Rack::Server，说明我们的rails应用也是一个Rack application
  def initialize(*)
    super
    set_environment
  end
  
  def set_environment
    ENV["RAILS_ENV"] ||= options[:environment]
  end
  
  def start   # 重写了Rack::Server的start方法
    print_boot_information
    trap(:INT) { exit }
    create_tmp_directories
    log_to_stdout if options[:log_stdout]
  
    super #调用Rack::Server的start方法
  ensure
    # The '-h' option calls exit before @options is set.
    # If we call 'options' with it unset, we get double help banners.
    puts 'Exiting' unless @options && options[:daemonize]
  end
  
  def print_boot_information
    url = "#{options[:SSLEnable] ? 'https' : 'http'}://#{options[:Host]}:#{options[:Port]}"
    puts "=> Booting #{ActiveSupport::Inflector.demodulize(server)}"
    puts "=> Rails #{Rails.version} application starting in #{Rails.env} on #{url}"
    puts "=> Run `rails server -h` for more startup options"
  
    if options[:Host].to_s.match(/0\.0\.0\.0/)
      puts "=> Notice: server is listening on all interfaces (#{options[:Host]}). Consider using 127.0.0.1 (--binding option)"
    end
  
    puts "=> Ctrl-C to shutdown server" unless options[:daemonize]
  end
  
  def create_tmp_directories
    %w(cache pids sessions sockets).each do |dir_to_make|
      FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
    end
  end
  
  def log_to_stdout
    wrapped_app # touch the app so the logger is set up
  
    console = ActiveSupport::Logger.new($stdout)
    console.formatter = Rails.logger.formatter
    console.level = Rails.logger.level
  
    Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
  end
end

def default_options  #重写了Rack的default_options，这里你可以修改端口号，设置启动环境的优先级，及pid文件位置和config.ru文件的路径
  super.merge({
    Port:               3000,
    DoNotReverseLookup: true,
    environment:        (ENV['RAILS_ENV'] || ENV['RACK_ENV'] || "development").dup,
    daemonize:          false,
    debugger:           false,
    pid:                File.expand_path("tmp/pids/server.pid"),
    config:             File.expand_path("config.ru")
  })
end


```
可以看到这个server继承了Rack::Server，说明，我们的rails 项目也是一个Rack application, rack  application  在启动的时候会去寻找一个叫做config.ru的文件:

``` ruby

require ::File.expand_path('../config/environment',  __FILE__)
run Rails.application

```

这个文件 require了config/enviromnent.rb 文件，并启动我们的application，这样我们的server就启动起来了。那么我们的服务启动的时候是怎么加载我们的项目的呢，让我们看一下 config/environment.rb文件:

``` ruby config/environment.rb

# Load the Rails application.
require File.expand_path('../application', __FILE__)

# Initialize the Rails application.
R4pro::Application.initialize!


```

看上面的代码，这个文件只做了两件事:加载application.rb 文件 初始化我们的项目。我们先来看看这个application.rb文件:

``` ruby config/application.rb

require File.expand_path('../boot', __FILE__)

require 'rails/all'

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(:default, Rails.env)

module R4pro
  class Application < Rails::Application
    # Settings in config/environments/* take precedence over those specified here.
    # Application configuration should go into files in config/initializers
    # -- all .rb files in that directory are automatically loaded.

    # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
    # Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
    # config.time_zone = 'Central Time (US & Canada)'

    # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
    # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
    # config.i18n.default_locale = :de
  end
end


```
这个文件的第一行，require  boot.rb 文件，这个文件我们在上面说过，就是load Gemfile文件，并run  bundler 。紧接着第二行，require 了 railties/lib/rails/all.rb文件，这个all文件的内容:

``` ruby   all.rb

require "rails"

%w(
  active_record
  action_controller
  action_view
  action_mailer
  rails/test_unit
  sprockets
).each do |framework|
  begin
    require "#{framework}/railtie"
  rescue LoadError
  end
end


```

第一行，require了 lib/rails.rb文件，接下来，加载rails的各个模块下的railtie文件。接下来继续看config/application.rb

``` ruby application.rb

module R4pro
  class Application < Rails::Application
    # Settings in config/environments/* take precedence over those specified here.
    # Application configuration should go into files in config/initializers
    # -- all .rb files in that directory are automatically loaded.

    # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
    # Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
    # config.time_zone = 'Central Time (US & Canada)'

    # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
    # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
    # config.i18n.default_locale = :de
  end
end

```

这个 class Application 继承自 Rails::Application，这个class将会在Rackup 文件中被传递到Rack server。我们再来看看Rails::Application 

``` ruby  rails/application.rb

class Application < Engine
  def inherited(base)
    super #调用Engine的super
    Rails.application ||= base.instance #这个Rails是在lib/rails.rb中定义的一个module，这个application是它的一个attributes
  end

  def config  #这个及时我们rails项目中的config/application.rb 文件中的config 注意这个方法是个类方法，这样我们在我们的项目的config/application.rb文件中才可以使用config直接调用
    @config ||= Application::Configuration.new(find_root_with_flag("config.ru", Dir.pwd))  #这个配置在rails/application/configuration.rb文件
  end
end 

```

这个Application 类继承了 Engine，这就是说，我们的rails application 也是一个engine。当一个类继承了这个类的时候，base.instance 将会赋值到Rails.application ,这个base.instance将会创建一个我们项目的实例。这就是说，我们可以在我们的项目的任何一个地方使用Rails.application来访问我们的项目的实例。我们看看Engine.rb文件:

``` ruby rails/engine.rb

class Engine < Railtie  #继承自 Railtie 类
  autoload :Configuration, "rails/engine/configuration" #加载 enging/configuration.rb这个文件

def inherited(base)
  unless base.abstract_railtie?
    Rails::Railtie::Configuration.eager_load_namespaces << base

    base.called_from = begin
      call_stack = if Kernel.respond_to?(:caller_locations)
        caller_locations.map(&:path)
      else
        # Remove the line number from backtraces making sure we don't leave anything behind
        caller.map { |p| p.sub(/:\d+.*/, '') }
      end

      File.dirname(call_stack.detect { |p| p !~ %r[railties[\w.-]*/lib/rails|rack[\w.-]*/lib/rack] })
    end
  end

  super  #调用Railtie这个类的inherited
end

def instance  #这个instance方法就是我们在application.rb 文件中 base.instance的出处
  @instance ||= new
end

end

```

这个Engine类继承了Railtie类，Railtie几乎遍布所有的ruby gems ，任何想要集成到rails项目的gems都应该有它自己的railtie。我们看看Railtie:

``` ruby  rails/railtie.rb

class Railtie
  autoload :Configuration, "rails/railtie/configuration" 
  class << self
    def inherited(base)
      unless base.abstract_railtie?
        subclasses << base
      end
    end
  end

```

这个类没有继承其他的类，但是他include了一个confirugration.rb 文件，无论这个Railtie类什么时候被继承，这个文件都会被加载。 我们再来看看关于网站配置的文件,在rails/application.rb文件中，include了  lib/rails/application/configuration.rb 文件:

``` ruby appalication/configuration.rb

module Rails
  class Application
    class Configuration < ::Rails::Engine::Configuration
      def initialize(*)
        super
        self.encoding = "utf-8"
        @allow_concurrency             = nil
        @consider_all_requests_local   = false
        @filter_parameters             = []
        @filter_redirect               = []
        @helpers_paths                 = []
        @serve_static_assets           = true
        @static_cache_control          = nil
        @force_ssl                     = false
        @ssl_options                   = {}
        @session_store                 = :cookie_store
        @session_options               = {}
        @time_zone                     = "UTC"
        @beginning_of_week             = :monday
        @log_level                     = nil
        @middleware                    = app_middleware
        @generators                    = app_generators
        @cache_store                   = [ :file_store, "#{root}/tmp/cache/" ]
        @railties_order                = [:all]
        @relative_url_root             = ENV["RAILS_RELATIVE_URL_ROOT"]
        @reload_classes_only_on_change = true
        @file_watcher                  = ActiveSupport::FileUpdateChecker
        @exceptions_app                = nil
        @autoflush_log                 = true
        @log_formatter                 = ActiveSupport::Logger::SimpleFormatter.new
        @eager_load                    = nil
        @secret_token                  = nil
        @secret_key_base               = nil

        @assets = ActiveSupport::OrderedOptions.new
        @assets.enabled                  = true
        @assets.paths                    = []
        @assets.precompile               = [ Proc.new { |path, fn| fn =~ /app\/assets/ && !%w(.js .css).include?(File.extname(path)) },
                                             /(?:\/|\\|\A)application\.(css|js)$/ ]
        @assets.prefix                   = "/assets"
        @assets.version                  = '1.0'
        @assets.debug                    = false
        @assets.compile                  = true
        @assets.digest                   = false
        @assets.cache_store              = [ :file_store, "#{root}/tmp/cache/assets/#{Rails.env}/" ]
        @assets.js_compressor            = nil
        @assets.css_compressor           = nil
        @assets.logger                   = nil
      end
    end
  end
end

```
这个Configurationl类在初始化的时候定义了很多的实例变量，这些变量大部分我们在做我们项目的配置的时候都见过。并且，这个类继承了::Rails::Engine::Configuration，我们再看看这个类:

``` ruby  engine/configuration.rb

module Rails
  class Engine
    class Configuration < ::Rails::Railtie::Configuration
      attr_reader :root
      attr_writer :middleware, :eager_load_paths, :autoload_once_paths, :autoload_paths

      def initialize(root=nil)
        super()
        @root = root
        @generators = app_generators.dup
      end
    end
  end
end


```

这个类继承了railtie 下的configuration类:

``` ruby railtie/configuration.rb

module Rails
  class Railtie
    class Configuration
      def initialize
        @@options ||= {}
      end
    end
  end
ene

```

看过了上面的代码之后，我们再看最后一个文件，这个文件就是在config/environment.rb 文件中的最后一行的方法:

``` ruby  config/environment.rb

# Load the rails application
require File.expand_path('../application', __FILE__)

# Initialize the rails application
QuillExpress::Application.initialize!

```

看一下最后一行，这一行就是我们项目的初始化过程，这个过程的实现在lib/rails/application.rb文件:

``` ruby rails/application.rb

def initialize!(group=:default) #:nodoc:
  raise "Application has been already initialized." if @initialized
  run_initializers(group, self) #执行初始化
  @initialized = true
  self
end

```

接下来看看run_initializers方法在哪

``` ruby  initializable.rb

  def run_initializers(group=:default, *args)
    return if instance_variable_defined?(:@ran)
    initializers.tsort_each do |initializer|
      initializer.run(*args) if initializer.belongs_to?(group)
    end
    @ran = true
  end

```

